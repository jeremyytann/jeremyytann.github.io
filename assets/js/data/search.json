[ { "title": "Advanced Dart", "url": "/posts/Advanced-Dart/", "categories": "Notes, Dart", "tags": "Dart", "date": "2022-08-30 12:45:00 +0800", "snippet": "Async and AwaitThe async and await keywords provide a declarative way to define asynchronous functions and use their results.AsyncAsync functions always return a promise.To define an async function, add async before the function body.Asynchronous Task is a task that whose results are not returned immediately.AwaitAwait expressions make promise-returning functions behave as though they are synchronous by suspending execution until the returned promise is fulfilled or rejected.Await keyword is only valid inside async functions.ExtensionsExtensions allow adding logic to existing classes.class Person { final String firstName; final String lastName;\t // constructor Person(this.firstName, this.lastName);}extension FullName on Person { String get fullName =&gt; '$firstName $lastName';}void call() { final person = Person('Noname', 'Unknown'); print(person.fullName);\t// prints Noname Unknown}FutureFuture is a class type for the data to be returned in the future.Future&lt;int&gt; multipleTwo(int number) { return Future.delayed(const Duration(seconds: 3), () { return number * 2; });}// async marks this function as asynchronous,// can be used to wait for the result of another functionvoid call() async { // await can be used to wait for the result of another function final result = await multipleTwo(2); print(result); // prints 4 after 3 seconds // another way to write the above code multipleTwo(10).then((value) =&gt; print(value));}GeneratorGenerators in Dart allows the user to produce a sequence of value easily.Synchronous GeneratorThe synchronous generator returns an iterable object that can be accessed sequentially.To implement synchronous generator function, mark the function body as sync*, and use yield statements to deliver values.Iterable&lt;int&gt; getNums() sync* { yield 1; yield 2; yield 3;}void call() { for (final value in getNums()) { print(value);\t// prints 1, 2, 3 }}Asynchronous GeneratorThe asynchronous generator returns a stream object. A stream provides a way to receive a sequence of events.To implement an asynchronous generator function, mark the function body as async*, and use yield statements to deliver values.Stream&lt;Iterable&lt;int&gt;&gt; getNums() async* { yield [1, 2, 3]; yield [4, 5, 6]; yield [7, 8, 9];}void call() async { await for (final value in getNums()) { print(value);\t// prints 1, 2, 3 }}StreamStreams provide an asynchronous sequence of data.Stream&lt;String&gt; printTest() { return Stream.periodic(const Duration(seconds: 1), (value) { return 'Test'; });}void call() async { await for (final value in printTest()) { print(value); // print Test every second }}References https://dart.dev/codelabs/async-await https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function https://www.geeksforgeeks.org/generators-in-dart/" }, { "title": "Basics of Dart", "url": "/posts/Basics-Of-Dart/", "categories": "Notes, Dart", "tags": "Dart", "date": "2022-08-28 16:35:00 +0800", "snippet": "Classes and MethodsClassA class is an abstract blueprint used to create more specific, concrete objects.ObjectObjects are instances of classes created with specific data.class Person { void sayHi() { print('Hi'); }}void call() { final person = Person(); person.sayHi();}Conditional Property AccessIn order to guard access to a property or method of an object that might be null.?. Add a question mark before the dot.List&lt;String&gt;? names = ['Jeremy'];List&lt;String&gt;? nulls = null;print(names?.length ?? 0);\t// prints 1print(nulls?.length ?? 0);\t// prints 0ConstructorsConstructor is a member function of a class that has the same name as the class name. It helps to initialize the object of a class.Factory Constructors can return instances that are not of the same class.class Person { final String name; // constructor Person(this.name); // factory constructor factory Person.createHuman() { return Person('Default'); } void printName() { print(name); }}void call() { final person = Person.createHuman(); person.printName();}OperatorsCustom OperatorsWe can define custom operators on your own classes.Overriding the == operatorclass Person { final String name; // constructor Person(this.name); @override // covariant force class to ignore type of parameters defined in super class bool operator ==(covariant Person other) =&gt; other.name == name; @override // hashCode is the identifier for instances of the class int get hashCode =&gt; name.hashCode;}void call() { final person1 = Person('John'); final person2 = Person('John'); print(person1 == person2);\t// prints true}Null Aware OperatorsNull aware operators are used to add null aware objects. They are listed below:? Add a question mark after the data type to make it nullable.String? name = null;?? is used to find the first non-null value.String? value1 = null;String? value2 = 'A';String? value3 = 'B';print(value1 ?? value3 ?? value2);\t// prints Bprint(value2 ?? value1 ?? value3);\t// prints A??= is used to assign value to a variable only if the variable is currently null.int? number = null;number ??= 5;print(number);\t// prints 5number ??= 10;print(number);\t// still prints 5References https://dart.dev/guides" }, { "title": "UML Class Diagram", "url": "/posts/UML-Class-Diagram/", "categories": "Notes, Object-Oriented Programming", "tags": "Object-Oriented Programming, UML", "date": "2022-07-23 18:55:00 +0800", "snippet": "UML Class NotationA class represents a concept that encapsulates state (attributes) and behavior (operations). Each attribute has a type and each operation has a signature.The class name is the only mandatory information.Class Name The name of the class appears in the first partition.Class Attributes Attributes are shown in the second partition. The attribute type is shown after the colon. Attributes map onto member variables (data members) in code.Class Operations (Methods) Operations are shown in the third partition. They are services the class provides. The return type of a method is shown after the colon at the end of the method signature. The return type of method parameters is shown after the colon following the parameter name. Operations map onto class methods in code.Class Visibility+ public attributes or operations- private attributes or operations# protected attributes or operationsParameter Directionalityin passed to the method by the callerinout passed to the method by the caller, and possibly modified by the method and is passed backout not set by the caller but is modified by the method, and is passed back outRelationships between classesInheritance / GeneralizationA generalization is a taxonomic relationship between a more general classifier and a more specific classifier. Each instance of the specific classifier is also an indirect instance of the general classifier. Thus, the specific classifier inherits the features of the more general classifier.The relationship is displayed as a solid line with a hollow arrowhead that points from the child element to the parent element. It represents an “is-a” relationship. An abstract class name is shown in italics. SubClass1 and SubClass2 are specializations of SuperClass.AssociationAssociations are relationships between classes in a UML Class Diagram.The relationship is displayed as a solid line between classes.Simply AssociationIt is a structural link between two peer classes. There is an association between Class1 and Class2.CardinalityCardinality is expressed in terms of: one-to-one one-to-many many-to-manyAggregationAggregation is a special type of association.The relationship is displayed as a solid line with an unfilled diamond at the association end, which is connected to the class that represents the aggregate. It represents a “part of” relationship. Class2 is part of Class1, many instances of Class2 can be associated with Class1. Objects of two classes have separate lifetimes.CompositionComposition is a special type of aggregation where parts are destroyed when the whole is destroyed.The relationship is displayed as a solid line with a filled diamond at the association end, which is connected to the class that represents the whole or composite. Objects of two classes live and die together. Class2 cannot stand by itself.DependencyDependency is a special type of association where an object of one class might use an object of another class in the code of a method. If the object is not stored in any field, then this is modeled as a dependency relationship.The relationship is displayed as a dashed line with an open arrow. Exists between two classes if changes to the definition of one may cause changes to the other. Class1 depends on Class2.RealizationRealization is a relationship between the blueprint class and the object containing its respective implementation level details. This object is said to realize the blueprint class. In other words, it is the relationship between the interface and the implementing class.The relationship is displayed as a dashed line with a hollow arrowhead that points from the class element to the interface element.References https://www.visual-paradigm.com/guide/uml-unified-modeling-language/uml-class-diagram-tutorial/ https://blog.csdn.net/weixin_44691608/article/details/117972671" }, { "title": "Model-View-Controller Pattern", "url": "/posts/Model-View-Controller-Pattern/", "categories": "Notes, Software Architecture", "tags": "Software Architecture, MVC", "date": "2022-07-23 15:32:00 +0800", "snippet": "Model-View-Controller (MVC)The Model-View-Controller (MVC) is an architectural pattern that separates an application into three main logical components: the model, the view, and the controller. Each of these components are built to handle specific development aspects of an application.ModelModel is the central component of the pattern. It is the application’s dynamic data structure, independent of the user interface. It is connected to the database, directly manages the data, logic and rules of the application. Adding or retrieving data is done in the model component.ViewData representation is done by the view component. It generates the user interface for the user.Views are created by the data which is collected by the model component but these data are not taken directly but through the controller. So, the view only speaks to the controller.ControllerController is the component that enables the interconnection between the views and the model. It responds to the user input and performs interactions on the data model objects.The controller does not have to worry about handling data logic, it just tells the model what to do. After receiving data from the model, it processes them and sends all the information to the view, and explains how to represent it to the user.Advantages of MVC MVC architecture will separate the user interface from business logic. Components are reusable, and easy to maintain. Different components of the application in MVC can be independently deployed and maintained.Disadvantages of MVC The complexity is high. It is not suitable for small applications. The inefficiency of data access in view.References https://towardsdatascience.com/everything-you-need-to-know-about-mvc-architecture-3c827930b4c1 https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller" }, { "title": "Process and Thread", "url": "/posts/Process-and-Thread/", "categories": "Notes, Operating System", "tags": "Operating System", "date": "2022-07-21 15:45:00 +0800", "snippet": "ProcessA process is an instance of a computer program in execution state along with all the necessary information required for its proper execution, like program counter, CPU registers, its activation state, memory security and management information etc.A process can create other processes which are known as Child Processes.The process takes more time to terminate and it is isolated, means it does not share the memory with any other process.States of ProcessNew, Ready, Running, Waiting, Terminated, and SuspendedThreadA thread is a lightweight and efficient process that can be managed independently by a scheduler. A process can contain multiple threads. The idea is to achieve parallelism by dividing a process into multiple threads.The thread takes less time to terminate as compared to the process but A thread shares information like data segment, code segment, files etc. with its peer threads while it contains its own registers, stack, counter etc.Types of ThreadUser Level Thread User threads are implemented by users. Operating System does not recognize user level threads. Implementation of User threads is easy. Context switch time is less, and requires no hardware support. If one user level thread performs blocking operation, then entire process will be blocked. User level threads can be created and managed more quickly. Any operating system can support user level threads.Kernel Level Thread Kernel threads are implemented by Operating System. Kernel threads are recognized by Operating System. Implementation of Kenel thread is complicated. Context switch time is more, and hardware support is needed. If one kernel thread perform blocking operation, then another thread can continue execution. Kernel level threads take more time to create and manage. Kernel level threads are operating system-specific.States of ThreadRunning, Ready, and BlockedAdvantages of Thread over ProcessResponsivenessIf the process is divided into multiple threads, if one thread completes its execution, then its output can be immediately returned.Faster context switchContext switch time between threads is lower compared to process context switch as threads are lighter than processes.Effective utilization of multiprocessor systemIf we have multiple threads in a single process, then we can schedule multiple threads on multiple processes. This will make process execution faster.Resource sharingResources like code, data, and files can be shared among all threads within a process.CommunicationCommunication between multiple threads is easier, as the threads shares common address space. While in process, we have to follow some specific communication technique for communication between two process.Enhanced throughput of the systemIf a process is divided into multiple threads, and each thread function is considered as one job, then the number of jobs completed per unit of time is increase, thus increasing the throughput of the system.References https://www.geeksforgeeks.org/difference-between-process-and-thread/ https://www.tutorialspoint.com/difference-between-process-and-thread https://www.geeksforgeeks.org/thread-in-operating-system/ https://www.geeksforgeeks.org/difference-between-user-level-thread-and-kernel-level-thread/" }, { "title": "Constructor and Destructor", "url": "/posts/Constructor-and-Destructor/", "categories": "Notes, Object-Oriented Programming", "tags": "Object-Oriented Programming", "date": "2022-07-20 17:36:00 +0800", "snippet": "ConstructorA constructor is a member function of a class that has the same name as the class name. It helps to initialize the object of a class.It can either accept the arguments or not. It is used to allocate the memory to an object of the class. It is called whenever an instance of the class is created. It can be defined manually with arguments or without arguments.There can be many constructors in a class. It can be overloaded with differing parameters.DestructorLike a constructor, destructor is also a member function of a class that has the same name as the class name, but it is preceded by a tilde(~) operator in C++. It helps to deallocate the memory of an object.It is called while the object of the class is freed or deleted. In a class, there is always a single destructor without any parameters. So, it cannot be overloaded.It is always called in the reverse order of the constructor. If a class is inherited by another class and both the classes have a destructor, then the destructor of the child class is called first, followed by the destructor of the parent or base class.ImplementationCodeclass Object {public: string name; // constructor Object(string name) { this-&gt;name = name; cout &lt;&lt; name &lt;&lt; \" constructor called.\" &lt;&lt; endl; } // destructor ~Object() { cout &lt;&lt; name &lt;&lt; \" destructor called.\" &lt;&lt; endl; }};int main() { Object one(\"one\"); // constructor called while (true) { Object two(\"two\"); // constructor called break; } // destructor called for two} // destructor called for oneOutputone constructor called.two constructor called.two destructor called.one destructor called.References https://www.geeksforgeeks.org/difference-between-constructor-and-destructor-in-c/ https://en.wikipedia.org/wiki/Constructor_(object-oriented_programming) https://en.wikipedia.org/wiki/Destructor_(computer_programming)" }, { "title": "Object Copying", "url": "/posts/Object-Copying/", "categories": "Notes, Object-Oriented Programming", "tags": "Object-Oriented Programming", "date": "2022-07-20 16:05:00 +0800", "snippet": "In object-oriented programming, object copying is creating a copy of an existing object, a unit of data in object-oriented programming.Methods of copyingThere are different strategies for making a copy of an object, referred to as shallow copy and deep copy.Shallow copyShallow copy stores the references of objects to the original memory address. It stores the copy of the original object and points the references to the objects. So, it reflects changes made to the new or copied object in the original object.Shallow copy is simple, fast and efficient.Deep copyDeep copy stores copies of the object’s value. It stores the copy of the original object and recursively copies the objects as well. So, it does not reflect changes made to the new or copied object in the original object.Deep copy is comparatively slower and has a cost associated with it.References https://www.quora.com/What-is-the-difference-between-a-shallow-copy-and-a-deep-copy-in-Java https://www.baeldung.com/cs/deep-vs-shallow-copy" }, { "title": "Basics of OOP", "url": "/posts/Basics-of-OOP/", "categories": "Notes, Object-Oriented Programming", "tags": "Object-Oriented Programming", "date": "2022-07-20 14:24:00 +0800", "snippet": "Object-Oriented ProgrammingObject-Oriented Programming is a programming paradigm that relies on the concept of classes and objects. It is used to structure a software program into simple, reusable pieces of code blueprints, which are used to create individual instances of objects.Benefits of OOP OOP models complex things as reproducible, simple structures Reusable, as OOP objects can be used across programs Allows for class-specific behavior through polymorphism Easier to debug, classes often contains all the applicable information to them Secure, protects information through encapsulationConcepts of OOPClassesA class is an abstract blueprint used to create more specific, concrete objects. Classes often represent broad categories that share attributes. These classes define what attributes an instance of this type will have, but not the value of those attributes for a specific object.Classes can also contain functions, called methods available only to objects of that type. These functions are defined within the class and perform some action helpful to that specific type of object.In a nutshell, classes are essentially user defined data types. Classes are where we create a blueprint for the structure of methods and attributes. Individual objects are instantiated, or created from this blueprint.ObjectsObjects are instances of classes created with specific data.AttributesAttributes are the information that is stored. Attributes are defined in the Class template. When objects are instantiated, individual objects contain data stored in the Attributes field.The state of an object is defined by the data in the object’s attributes field.MethodsMethods represent behaviors. Methods perform actions that might return information about an object or update an object’s data. The method’s code is defined in the class definition.When individual objects are instantiated, these objects can call the methods defined in the class.Principles of OOPThe four principles of object-oriented programming are encapsulation, abstraction, inheritance and polymorphism.InheritanceInheritance allows classes to inherit features of other classes and it supports reusability. If basic attributes and behaviors are defined in a parent class, child classes can be created extending the functionality of the parent class, and adding additional attributes and behaviors.The benefits of inheritance are programs can create a generic parent class, and then create more specific child classes as needed. This simplifies overall programming as child classes automatically gain access to functionalities within their parent class.EncapsulationEncapsulation means containing all important information inside an object, and only exposing selected information to the outside world. Attributes and behaviors are defined by code inside the class template.When an object is instantiated from the class, the data and methods are encapsulated in that object. Encapsulation hides the internal software code implementation inside a class, and hides internal data of inside objects.Encapsulation requires defining some fields as private and some as public.Private/Internal Interface methods and properties, accessible from other methods of the same class.Public/External Interface methods and properties, accessible also from outside the class.The benefits of encapsulation are: Adds security, as only public methods and attributes are accessible from the outside. Protects against common mistakes, as only public fields and methods accessible, so developers will not acidentally change something important. Protects IP, as code is hidden in a class, only public methods are accessible by the outside developers. Supportable, as most code undergoes updates and improvements. Hides complexity, as no one can see what’s behind the objects.AbstractionAbstraction means that the user interacts with only selected attributes and methods of an object. It uses simplified high level tools, to access a complex object.Abstraction is using simple classes to represent complexity. It is an extension of encapsulation. For example, you don’t have to know all the details of how the engine works to drive a car.Abstraction serves an important security role. By only displaying selected pieces of data, and only allowing data to be accessed through classes and modified through methods, data will be protected from exposure.The benefits of abstraction are: Simple, high level user interfaces. Complex code is hidden. Adds security, as data is protected from exposure. Easier software maintenance, as code updates rarely affect the abstraction.PolymorphismPolymorphism means designing objects to share behaviors. Using inheritance, objects can override shared parent behaviors, with specific child behaviors. Polymorphism allows the same method to execute different behaviors in two ways: method overriding and method overloading.Method overriding Runtime polymorphism uses method overriding. In method overriding, a child class can provide a different implementation than its parent class.Method overloading Compile Time polymorphism uses method overloading. Methods or functions may have the same name, but a different number of parameters passed into the method call. Different results may occur depending on the number of parameters passed in.The benefits of polymorphism are: Objects of different types can be passed through the same interface. Method overriding and method overloading.References https://www.educative.io/blog/object-oriented-programming https://www.freecodecamp.org/news/object-oriented-programming-concepts-21bb035f7260/" }, { "title": "归并排序 Merge Sort", "url": "/posts/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-Merge-Sort/", "categories": "Notes, Algorithm", "tags": "Algorithm, Sorting", "date": "2022-07-11 16:17:00 +0800", "snippet": "归并排序简介根据具体的实现，归并排序包括由上往下和由下往上的两种方式。由下往上的归并排序将要排序的数列分成若干个长度为 1 的子数列，再将这些数列两两合并。得到若干个长度为 2 的有序数列后，再将这些数列两两合并，得到若干个长度为 4 的有序数列。重复以上操作直到合并成一个数列，就可以得到有序数列了。由上往下的归并排序由上往下与由下往上在排序上是反方向的。它基本包括 3 个步骤：分解 — 将当前区间一分为二，即求分裂点 mid = (low + high) / 2。求解 — 递归地对两个子区间 a[low…mid] 和 a[mid+1…high] 进行归并排序，递归的终结条件是子区间的长度为 1。合并 — 将已排序的两个子区间 a[low…mid] 和 a[mid+1…high] 归并为一个有序的区间 a[low…high]。归并排序实现由上往下的归并排序由上往下的归并排序采用递归的方式实现。其原理如下图：通过由上往下的归并排序来对数列 {80,30,60,40,20,10,50,70} 进行排序： 将数列 {80,30,60,40,20,10,50,70} 看作由两个有序的子数列 {80,30,60,40} 和 {20,10,50,70} 组成，对两个有序子数列进行排序即可。 将子数列 {80,30,60,40} 看作由两个有序的子数列 {80,30} 和 {60,40} 组成。 将子数列 {20,10,50,70} 看作由两个有序的子数列 {20,10}和{50,70} 组成。 将子数列 {80,30} 看作由两个有序的子数列 {80} 和 {30} 组成。 将子数列 {60,40} 看作由两个有序的子数列 {60} 和 {40} 组成。 将子数列 {20,10} 看作由两个有序的子数列 {20} 和 {10} 组成。 将子数列 {50,70} 看作由两个有序的子数列 {50} 和 {70} 组成。由下往上的归并排序通过由下往上的归并排序来对数列 {80,30,60,40,20,10,50,70} 进行排序： 将数列 {80,30,60,40,20,10,50,70} 看作由 8 个有序的子数列 {80}, {30}, {60}, {40}, {20}, {10}, {50} 和 {70} 组成。 将这 8 个有序的子数列两两合并，得到 4 个有序的子数列 {30,80}, {40,60}, {10,20} 和 {50,70}。 将这 4 个有序的子数列两两合并，得到 2 个有序的子数列 {30,40,60,80} 和 {10,20,50,70}。 将这 2 个有序的子数列两两合并，得到 1 个有序的子数列 {10,20,30,40,50,60,70,80}。复杂度与稳定性归并排序时间复杂度假设要排序的数列中有 N 个数，遍历一趟的时间复杂度为 $O(N)$。由于归并排序的形式就像一颗二叉树，需要遍历的次数就是二叉树的深度。根据完全二叉树，可以得出归并排序的时间复杂度为 $O(N~lg~N)$。归并排序稳定性归并排序是稳定的算法，其满足稳定算法的定义，即假设在数列中存在 a[i] = a[j]，若 a[i] 在排序之前处在 a[j] 前面，并在排序之后仍处在 a[j] 前面，则该排序算法是稳定的。代码实现由上往下的归并排序void merge(int* arr, int left, int mid, int right) { int* temp = (int*)malloc((right-left + 1) * sizeof(int)); int i = left; int j = mid + 1; int count = 0; while (i &lt;= mid &amp;&amp; j &lt;= right) { if (arr[i] &lt;= arr[j]) { temp[count++] = arr[i++]; } else { temp[count++] = arr[j++]; } } while (i &lt;= mid) { temp[count++] = arr[i++]; } while (j &lt;= right) { temp[count++] = arr[j++]; } for (i = 0; i &lt; count; i++) { arr[left + i] = temp[i]; } free(temp);}void mergeSortUpToDown(int* arr, int left, int right) { if (left &gt;= right) { return; } int mid = (left + right) / 2; mergeSortUpToDown(arr, left, mid); mergeSortUpToDown(arr, mid+1, right); merge(arr, left, mid, right);}由下往上的归并排序void merge(int* arr, int left, int mid, int right) { int* temp = (int*)malloc((right-left + 1) * sizeof(int)); int i = left; int j = mid + 1; int count = 0; while (i &lt;= mid &amp;&amp; j &lt;= right) { if (arr[i] &lt;= arr[j]) { temp[count++] = arr[i++]; } else { temp[count++] = arr[j++]; } } while (i &lt;= mid) { temp[count++] = arr[i++]; } while (j &lt;= right) { temp[count++] = arr[j++]; } for (i = 0; i &lt; count; i++) { arr[left + i] = temp[i]; } free(temp);}void mergeGroups(int* arr, int length, int gap) { int i; int lengths = 2 * gap; \t// 两个相邻的子数列的长度 // 将每 2 个相邻的子数列合并排序 for (i = 0; i + 2*gap &lt; length; i += (2*gap)) { merge(arr, i, i + gap - 1, i + 2*gap - 1); } // 若 i+gap-1 &lt; length-1，则剩余一个子数列没有配对 // 将该子数列合并到已排序的数列中 if (i+gap-1 &lt; length-1) { merge(arr, i, i + gap - 1, length - 1); }}void mergeSortDownToUp(int* arr, int length) { int n; if (length &lt;= 0) { return; } for (n = 1; n &lt; length; n *= 2) { mergeGroups(arr, length, n); }}参考文章 https://www.cnblogs.com/skywang12345/p/3597641.html https://pdai.tech/md/algorithm/alg-sort-x-merge.html" }, { "title": "选择排序 Selection Sort", "url": "/posts/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F-Selection-Sort/", "categories": "Notes, Algorithm", "tags": "Algorithm, Sorting", "date": "2022-07-11 16:04:00 +0800", "snippet": "选择排序简介选择排序的基本思想是，在未排序的数列中找到最小或最大的元素，将其存放在数列的起始位置。接着，再从剩余未排序的元素中继续寻找最小或最大的元素，逐个放到已排序数列的末尾。以此类推，直到所有元素均排列完毕。选择排序实现下面以数列 {20,40,30,10,60,50} 为例，演示选择排序的过程。第一趟，i = 0。此时，找到最小值 a[3] = 10，并将其与 a[0] 交换位置，数列变为 {10,40,30,20,60,50}。第二趟，i = 1。此时，找到最小值 a[3] = 20，并将其与 a[1] 交换位置，数列变为 {10,20,30,40,60,50}。第三趟，i = 2。此时，找到最小值 a[2] = 30。由于已处在正确位置，因此不做任何处理。第四趟，i = 3。此时，找到最小值 a[3] = 40。由于已处在正确位置，因此不做任何处理。第五趟，i = 4。此时，找到最小值 a[5] = 50，并将其与 a[4] 交换位置，数列变为 {10,20,30,40,50,60}。复杂度与稳定性选择排序时间复杂度选择排序的时间复杂度是 $O(N^2)$。假设要被排序的数列中有 N 个数，遍历一趟的时间复杂度为 $O(N)$。由于算法需要遍历 N-1 次，因此选择排序的时间复杂度为 $O(N^2)$。选择排序稳定性使用数组实现的选择排序是不稳定的，而用链表实现的选择排序则是稳定的。代码实现输入：arr 为要排序数列，n 为数列的元素个数void selectionSort(int* arr, int n) { int i, j, min, temp; for (i = 0; i &lt; n; i++) { min = i; for (j = i + 1; j &lt; n; j++) { if (arr[j] &lt; arr[min]) { min = j; } } if (min != i) { temp = arr[i]; arr[i] = arr[min]; arr[min] = temp; } }}参考文章 https://www.cnblogs.com/skywang12345/p/3597641.html https://pdai.tech/md/algorithm/alg-sort-x-select.html" }, { "title": "插入排序 Insertion Sort", "url": "/posts/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F-Insertion-Sort/", "categories": "Notes, Algorithm", "tags": "Algorithm, Sorting", "date": "2022-07-11 15:45:00 +0800", "snippet": "插入排序简介插入排序的基本思想是，把 n 个待排序的元素看成一个有序表和一个无序表。开始时，有序表中只包含一个元素，无序表中则包含 n-1 个元素。排序过程中每次从无序表中取出第一个元素，将它插入到有序表中适当的位置，使之成为新的有序表。只要重复 n-1 次，即可完成排序过程。插入排序实现下面选取插入排序的一个中间过程对其进行说明。假设 {20,30,40,10,60,50} 中的前 3 个数已经排列过，是有序的了。接下来对 10 进行排列。图中将数列分为有序区以及无序区。这里需要做的只是取出无序区中的第一个数，并找到它在有序区所对应的位置。若有必要的话，则对有序区中的相关数据进行移位。复杂度与稳定性插入排序时间复杂度插入排序的时间复杂度是 $O(N^2)$。假设要被排序的数列中有 N 个数，遍历一趟的时间复杂度为 $O(N)$。由于算法需要遍历 N-1 次，因此插入排序的时间复杂度为 $O(N^2)$。插入排序稳定性插入排序是稳定的算法，其满足稳定算法的定义，即假设在数列中存在 a[i] = a[j]，若 a[i] 在排序之前处在 a[j] 前面，并在排序之后仍处在 a[j] 前面，则该排序算法是稳定的。代码实现输入：arr 为要排序数列，n 为数列的元素个数void insertionSort(int* arr, int n) { int i, j, k; for (i = 1; i &lt; n; i++) { \t// 为 a[i] 在 a[0...i-1] 的有序区中找一个合适的位置 for (j = i - 1; j &gt;= 0; j--) { if (arr[j] &lt; arr[i]) { break; } } // 若找到一个合适的位置 if (j != i - 1) { // 将比 a[i] 大的数据往后移 int temp = arr[i]; for (k = i - 1; k &gt; j; k--) { arr[k+1] = arr[k]; } // 最后将 a[i] 放在该位置上 arr[k+1] = temp; } }}参考文章 https://www.cnblogs.com/skywang12345/p/3596881.html https://pdai.tech/md/algorithm/alg-sort-x-insert.html" }, { "title": "快速排序 Quick Sort", "url": "/posts/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-Quick-Sort/", "categories": "Notes, Algorithm", "tags": "Algorithm, Sorting", "date": "2022-07-10 18:25:00 +0800", "snippet": "快速排序简介快速排序的基本思想是，选择一个基准数，通过一趟排序将要排序的数据分割成独立的两部分。其中一部分的所有数据都比另外一部分的所有数据都要小。随后，再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序数列。快速排序实现首先，从数列中挑一个基准值，并将所有比基准值小的摆放在基准前面，所有比基准值大的都摆在基准后面。在这个分区退出后，该基准就处于数列的中间位置。之后，再递归地把基准值前面的子数列和基准后面的子数列进行排序即可。下面以数列 a = {30, 40, 60, 10, 20, 50} 为例，演示快速排序的过程。第一趟中，i = 0，j = 5，基准值 x 设为 a[i]，即 x = 30。首先由右向左查找小于 x 的数，找到满足条件的数 a[j] = 20。此时 i = 0，j = 4，将 a[j] 赋值给 a[i]。接着由左向右查找大于 x 的数，找到满足条件的数 a[i] = 40。此时 i = 1，j = 4，将 a[i] 赋值给 a[j]。接着由右向左查找小于 x 的数，找到满足条件的数 a[j] = 10。此时 i = 1，j = 3，将 a[j] 赋值给 a[i]。接着由左向右查找大于 x 的数，找到满足条件的数 a[i] = 60。此时 i = 2，j = 3，将 a[i] 赋值给 a[j]。接着由右向左查找小于 x 的数，没有找到满足条件的数。此时 i &gt;= j，停止查找，并将 x 赋值给 a[i]。按照同样的方法，对子数列进行递归遍历。最后就可以得到有序数列了。复杂度与稳定性快速排序时间复杂度假设被排序的数列中有 N 个数，遍历一趟的时间复杂度为 $O(N)$。快速排序采用分治法进行遍历，因此可以将它视为一棵二叉树，即所需要遍历的次数为二叉树的深度。 二叉树的深度至少是 $lg(N+1)$，因此快速排序的遍历次数最少是 $lg(N+1)$ 次。 二叉树的深度最大是 $N$，因此快速排序的遍历次数最多是 $N$ 次。快速排序的时间复杂度在最坏情况下是 $O(N^2)$，平均的时间复杂度是 $O(N~lg~N)$。快速排序稳定性快速排序是不稳定的算法，其不满足稳定算法的定义，即假设在数列中存在 a[i] = a[j]，若 a[i] 在排序之前处在 a[j] 前面，并在排序之后仍处在 a[j] 前面，则该排序算法是稳定的。代码实现输入：arr 为要排序数列，left 为要排序数列的开头下标，right 为要排序数列的末尾下标void quickSort(int* arr, int left, int right) { if (left &lt; right) { int i, j, pivot; i = left; j = right; pivot = arr[i]; while (i &lt; j) { while (i &lt; j &amp;&amp; arr[j] &gt; pivot) { \tj--; } if (i &lt; j) { arr[i++] = arr[j]; } while (i &lt; j &amp;&amp; arr[i] &lt; pivot) { i++; } if (i &lt; j) { arr[j--] = arr[i]; } } arr[i] = pivot; quickSort(arr, left, i-1); quickSort(arr, i+1, right); }}参考文章 https://www.cnblogs.com/skywang12345/p/3596746.html https://pdai.tech/md/algorithm/alg-sort-x-fast.html" }, { "title": "冒泡排序 Bubble Sort", "url": "/posts/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F-Bubble-Sort/", "categories": "Notes, Algorithm", "tags": "Algorithm, Sorting", "date": "2022-07-10 15:40:00 +0800", "snippet": "冒泡排序简介冒泡排序是一种比较简单的排序算法。它会遍历若干次要排序的数列。每次遍历时，它都会由前往后依次比较相邻两个数的大小。若前者比后者大，则交换他们的位置。这样在一次遍历后，最大的元素就在数列的末尾了。采用相同的方法再次遍历时，第二大的元素将被排列在最大元素之前。重复此操作，直到整个数列都有序为止。冒泡排序实现下面以数列 a = {20, 40, 30, 10, 60, 50} 为例，演示冒泡排序的过程。当 i = 5, j = 0 时，a[0] &lt; a[1]。此时，不做任何处理。当 i = 5, j = 1 时，a[1] &gt; a[2]。因此，a[1] 和 a[2] 交换位置。当 i = 5, j = 2 时，a[2] &gt; a[3]。因此，a[2] 和 a[3] 交换位置。当 i = 5, j = 3 时，a[3] &lt; a[4]。此时，不做任何处理。当 i = 5, j = 4 时，a[4] &gt; a[5]。因此，a[4] 和 a[5] 交换位置。第一趟排序完毕后，数列由 {20, 40, 30, 10, 60, 50} 变为 {20, 30, 10, 40, 50, 60}。根据此方法，数列将在遍历 N-1 次后变得有序。但实际上，这一个数列在遍历到第三趟时就已经变得有序了，第四趟以及第五趟遍历中并没有任何数据交换。为了提高冒泡排序的效率，可以添加一个标记，用以记录一趟遍历中是否发生了数据交换。若一趟遍历中没有发生数据交换，则表示数列已完成排序。复杂度与稳定性冒泡排序时间复杂度假设被排序的数列中有 N 个数，遍历一趟的时间复杂度为 $O(N)$。由于算法需要遍历 N-1 次，因此冒泡排序的时间复杂度为 $O(N^2)$。冒泡排序稳定性冒泡排序是稳定的算法，其满足稳定算法的定义，即假设在数列中存在 a[i] = a[j]，若 a[i] 在排序之前处在 a[j] 前面，并在排序之后仍处在 a[j] 前面，则该排序算法是稳定的。代码实现输入：arr为要排序数列，n为数列元素个数void bubbleSort(int arr[], int n) { int i, j, temp; for (i = n - 1; i &gt; 0; i--) { for (j = 0; j &lt; i; j++) { if (arr[j] &gt; arr[j+1]) { temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; } } }}void optimized_bubbleSort(int arr[], int n) { int i, j, temp, flag; for (i = n - 1; i &gt; 0; i--) { flag = 0; for (j = 0; j &lt; i; j++) { if (arr[j] &gt; arr[j+1]) { temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; flag = 1; } } if (flag == 0) { break; } }}参考文章 https://www.cnblogs.com/skywang12345/p/3596232.html https://pdai.tech/md/algorithm/alg-sort-x-bubble.html" }, { "title": "IPv6 协议", "url": "/posts/IPv6-%E5%8D%8F%E8%AE%AE/", "categories": "Notes, Computer Network", "tags": "Computer Network", "date": "2022-05-30 19:19:00 +0800", "snippet": "随着 Internet 的快速发展，IPv4 已经不适用了。其有 IP 地址空间耗尽问题、安全性问题以及服务质量问题等。解决 IP 地址耗尽问题的措施如下： 采用无类别编址 CIDR，使 IP 地址的分配更加合理 采用网络地址转换 NAT 方法以节省全球 IP 地址 采用具有更大地址空间的新版本 IP 协议 IPv6IETF 于 1992 年提出了推出下一代 IP，即 IP Next Generation，也称为 IPv6。IPv6 于 1998 年称为标准草案，RFC 2460—2463。IPv6 引入的主要变化有： 更大的地址空间，由 IPv4 的 32 位增大到了 128 位 扩展的地址层次结构，有多种组织方式 灵活的首部格式 改进的选项 允许协议继续扩充 支持即插即用，自动配置 支持资源的预分配IPv6 地址IPv6 数据报的目的地址可以是三种基本类型地址之一。 单播 (unicast)：传统的点对点通信 组播/多播 (multicast)：一点对多点的通信 任意播 (anycast)：IPv6 增加的类型，任意播的目的站是一组计算机，但数据报在交付时只交付其中的一个，通常是距离最近的一个。IPv6 地址采用冒号十六进制记法 (colon hexadecimal notation)。每个 16 位的值用十六进制值表示，各值之间用冒号分隔。例如：68E6:8C64:FFFF:FFFF:0:1180:960A:FFFFCIDR 的斜线表示法仍然可用。例如 60 位前缀的 12AB00000000CD3 可记为：12AB:0000:0000:CD30:0000:0000:0000:0000/60或者采用零压缩与结合点分十进制的后缀的 12AB::CD30:0:0:0:0/60 与 12AB:0:0:CD30::/60IPv6 首部IPv6 的数据报结构如下： 首部长度固定为 40 字节，称为基本首部 (base header) 取消了不必要的功能，首部字段数减少到 8 个 取消了首部的校验和字段，加快了路由器处理数据报的速度 在基本首部的后面允许有零个或多个扩展首部 所有的扩展首部和数据合起来，称之为数据报的有效载荷 (payload)基本首部基本首部的字段数为 8 个。版本 Version4 位，协议版本。对于 IPv6 而言，该字段为 6。流量类别 Traffic class8 位，用于区分 IPv6 数据报的类别或优先级。流标号 Flow label流，是从特定源点到特定终点的一系列数据报。其所经过路径上的路由器都保证特定的服务质量，所有属于同一个流的数据报都具有相同的流标号。有效载荷长度 Payload length16 位，标识数据报除去基本首部以外的长度，最大值为 64KB，单位为字节数。下一个首部 Next header8 位，相当于 IPv4 的协议字段或可选字段。跳数限制 Hop limit8 位，数据报发出时设定跳数限制，路由器在转发数据报时，将该字段的值减 1。当其为 0 时，则将此数据报丢弃。源地址 Source address128 位，数据报发送方的 IP 地址。目的地址 Destination address128 位，数据报接收方的 IP 地址。扩展首部原 IPv4 首部中的选项功能都放在 IPv6 扩展首部中。数据报途中所经过的路由器不处理除逐跳选项以外的扩展首部，扩展首部由源和目的站的主机处理，因此路由器的处理效率大大提高。在 RFC 2460 中，定义了六种扩展首部： 逐跳选项 路由选择 分片 鉴别 封装安全有效载荷 目的站选项IPv4 向 IPv6 过渡向 IPv6 的过渡只能采用逐步演进的方法，还必须使新安装的 IPv6 系统能够向后兼容。IPv6 系统必须能够接收和转发 IPv4 分组，并且能够为 IPv4 分组选择路由。目前实现 IPv4/IPv6 互操作的技术主要有双协议栈以及隧道技术。双协议栈 (dual stack)主机或路由器装有两个协议栈，一个 IPv4 和一个 IPv6，根据需要使用不同的协议栈进行通信。隧道技术 (tunneling)将 IPv6 数据报重新封装后，通过 IPv4 网络传输，即 IPv6 数据报作为 IPv4 数据报的数据部分。 重新封装为 IPv4 数据报后，IPv4 包头中协议类型字段为 41" }, { "title": "应用层 Application Layer", "url": "/posts/%E5%BA%94%E7%94%A8%E5%B1%82-Application-Layer/", "categories": "Notes, Computer Network", "tags": "Computer Network", "date": "2022-05-12 20:06:00 +0800", "snippet": "应用层协议是为了解决某一类应用的问题。由于网络应用的多样性，应用层的协议也种类繁多。应用层的许多协议都是基于客户/服务器方式，其描述的是进程之间服务和被服务的关系。客户 (client) 和服务器 (server) 都是指通信中所涉及的两个应用进程。这里主要的特征是：客户是服务请求方，而服务器则是服务提供方。套接字编程接口套接字 (socket) 是最常用的应用层编程接口。网络子系统作为操作系统的一部分，以应用编程接口 (Application Programming Interface, API) 的形式向应用程序提供调用接口。经典的 socket 编程接口采用同步调用方式，又称阻塞式。这是因为调用 recv() 时，调用进程将被阻塞，直到收到数据为止。而 Windows 这类基于事件驱动的系统中，程序的执行由事件驱动，需要异步事件驱动方式的套接字编程接口。因此 Microsoft 推出了 WinSock 编程接口，在阻塞式调用基础上，增加了异步调用方式。在阻塞式调用模式上，WinSock 与经典的 socket 兼容。常见的 socket 接口函数创建一个socketSOCKET socket ( int af, int type, int protocol )将本地地址与 socket 绑定int bind ( SOCKET s, struct sockaddr *name, int namelen )在套接字上舰艇连接请求int listen ( SOCKET s, int backlog )与 name 指定的地址建立连接int conect ( SOCKET s, struct sockaddr *name, int namelen )接受与本 socket 的连接请求SOCKET accept ( SOCKET s, struct sockaddr *addr, int *addrlen )在连接的 socket 上发送数据int send ( SOCKET s, char* buf, int len, int flags )在连接的活绑定的 socket 上接收数据int recv ( SOCKET s, char* buf, int len, int flags )向指定的目标地址发送数据int sendto ( SOCKET s, char* buf, int len, int flags, struct sockaddr *to, int tolen )在 socket 上接收数据并记录源地址int recvfrom ( SOCKET s, char* buf, int len, int flags, struct sockaddr *from, int* fromlen )域名系统 DNS域名系统 (Domain Name System, DNS) 是 Internet 使用的命名系统。其基于 UDP 协议实现。当应用程序需要进行域名解析时，调用域名解析程序 (resolver)，即成为 DNS 的一个客户。该程序会向本地域名服务器发送域名解析请求 (UDP 报文)，其中包含待解析的域名。本地域名服务器在查找域名后，会返回应答报文，其中包含对应的 IP 地址。Internet 的域名结构Internet 采用层次结构的命名树作为主机的名字，并使用分布式的域名系统 DNS。域名不区分大小写，且长度不超过 255 字符。其层次树状结构的命名方法为：… . 三级域名 . 二级域名 . 顶级域名。顶级域名 (Top Level Domain, TLD)顶级域名可分为国家顶级域名以及通用顶级域名。国家顶级域名，如 .cn 表示中国、.us 表示美国、.uk 表示英国等。通用顶级域名，如 .com 表示公司和企业、.net 表示网络服务机构、.org 表示非盈利性组织以及 .edu 表示教育机构等。域名服务器多个域名服务器上运行专门的域名服务器程序，以完成域名到 IP 地址的解析 (resolve)。域名服务器会定期把数据复制到几个域名服务器来保存，其中一个是主域名服务器，其他的则是辅助域名服务器。域名服务器分为四类：根域名服务器根域名服务器知道所有的顶级域名服务器的域名和 IP 地址。当本地域名服务器无法解析域名时，就会求助于根域名服务器。顶级域名服务器负责管理在该顶级域名服务器注册的所有二级域名。权限域名服务器负责一个区 (zone) 的域名服务器。本地域名服务器也称为默认域名服务器。域名解析过程域名服务器的监听端口号为 53。为了提高域名查询的效率，域名服务器上通常会设置高速缓存。主机向本地域名服务器的查询一般采用递归查询。如果本地域名服务器不知道被查询域名的 IP 地址，就会以 DNS 客户的身份，向根域名服务器继续发出查询请求报文。 递归查询是一个接一个往下问，查询到后再一个接一个返回结果。本地域名服务器向根域名服务器的查询通常是采用迭代查询。当根域名服务器收到本地域名服务器的迭代查询请求报文时，要不就给出所要查询的 IP 地址，否则就告诉本地域名服务器下一步应该向哪一个域名服务器查询，让本地域名服务器进行后续的查询。 迭代查询是一个服务器对多个服务器进行轮询。文件传送协议文件传送协议 (File Transfer Protocol, FTP) 使用客户/服务器方式，一个 FTP 服务器进程可以同时为多个客户进程提供服务。FTP 的服务器进程由两大部分组成，一个负责接收新请求的主进程以及若干个负责处理单个请求的从属进程。主进程的工作步骤 打开熟知端口 (端口号为 21)，使客户进程能连接上 等待客户进程发出连接请求 启动从属进程处理客户进程发来的请求。从属进程在处理完客户进程的请求后就会终止，运行期间还可能会根据需要创建其他子进程 回到等待状态，继续接收其他客户进程发来的请求 主进程与从属进程的处理是并发进行的TCP 连接FTP 使用 2 个 TCP 连接，控制连接和数据连接控制连接控制连接会在整个会话期间一直保持打开。FTP 客户发出的传送请求通过控制连接发送给服务器端的控制进程，但控制连接不用来传送文件。数据连接收到 FTP 客户发送来的文件传输请求后，服务器端的控制进程创建数据传送进程和数据连接。数据传送进程实际完成文件的传送，传送完毕后关闭数据传送链接，并结束运行。万维网 WWWWWW 为 World Wide Web 的缩写，是分布式超媒体 (hypermedia) 系统，它是超文本 (hypertext) 系统的扩充。统一资源定位符 URLURL 的全称为 Uniform Resource Locator，是对 Internet 上资源位置和访问方法的一种简洁表示，用以标识分布在整个因特网上的万维网文档。URL不区分大小写，其一般形式为：协议://主机:端口/路径。主机存放资源的主机在 Internet 中的域名端口 和 路径有时可省略。使用 http 协议时，省略端口将使用熟知端口号 80，省略路径F则指向主页 (home page)。超文本传输协议 HTTPHTTP 的全称为 HyperText Transfer Protocol，其基于 TCP 协议，是万维网上可靠地交换文件的重要基础，用以实现万维网上各种超链的链接。HTTP 是面向事务的客户/服务器协议，是无状态的，即服务器不记录客户端的访问状态。其基本工作原理为： Web 服务的熟知端口号为 80，服务器通常在该端口上监听。 客户端需要请求某个页面时，与服务器建立 TCP 连接。 之后请求传送文件，并进行文件的传送。 传送完毕后释放 TCP 连接。报文类型HTTP 的报文类型可分为请求报文以及响应报文。请求报文是从客户向服务器发送请求报文，而响应报文则是从服务器到客户的回答。由于 HTTP 是面向正文的 (text-oriented)，报文中的字段都是 ASCII 码串，因此每个字段的长度都是不确定的。HTTP 应答报文的开始行是状态行，其包括三项内容：HTTP 的版本、状态码以及解释状态码的简单短语。HTTP/1.0HTTP/1.0 请求一个万维网文档所需的步骤与时间： 首先建立 TCP 连接，需 3 次握手。 在 2 次握手后，第 3 次握手报文的数据部分可传送 HTTP 请求报文。因此请求文档所需时间为：文档传输时间 + 2 倍 RTT 时间。由于每传送一个文件都需要建立一次 TCP 连接，而一个 Web 页面常常包含数量众多的文件，导致效率过低。因此有了 HTTP/1.1 的改进。HTTP/1.1HTTP/1.1 协议使用持续连接 (persistent connection)。服务器发送响应后，会在一段时间内保持连接，使客户与服务器可以继续传送后续的 HTTP 请求报文和响应报文。这并不局限于传送同一个页面上链接的文档，而是只要这些文档都在同一个服务器上即可。目前主流的浏览器都默认支持 HTTP/1.1。超文本标记语言 HTMLHTML 的全称为 HyperText Markup Language，用以存储和表示万维网文档。RFC 1866 为 HyperText Markup Language - 2.0。HTML 定义了许多用于排版的命令，即标签 (tag)。HTML 把各种标签嵌入到万维网的页面中，构成 HTML 文档。浏览器从服务器读取 HTML 文档后，按照其中嵌入的各种标签，根据显示器尺寸和分辨率显示页面。 仅当 HTML 文档是以 html 或 htm 为后缀时，浏览器才会对此文档的各种标签进行解释安全的 HTTP 协议：HTTPSHTTPS 是安全的 HTTP 协议，其建立在 SSL 基础上。其熟知端口号为 443，而不是 80。SSL 的全称为 Secure Socket Layer，为 TCP 协议提供信息加密和完整性。NetScape 于 1994 年开发，1996 年发布 SSL 3.0，1999 年 IETF 在 SSL 3.0 的基础上推出了 TLS (Transport Layer Security)。SSL/TLS 已被浏览器广泛支持，很多 Web 应用利用 HTTPS 协议实现安全传输。SSL会话的建立过程如下： 浏览器 A 将其支持的加密算法告知服务器 B 服务器 B 将自己所支持的加密算法与浏览器所支持的加密算法进行交集，再选定一种加密算法 服务器 B 以数字证书的方式将自己的公钥传送给浏览器 A 浏览器 A 鉴别服务器 B 的证书后，从中取得公钥 浏览器 A 产生秘密数，并使用此秘密数产生会话密钥。随后将密钥发送给服务器 B 服务器 B 也使用此秘密数产生会话密钥。 到此完成 SSL 会话建立，使用会话密钥加密，开始数据传输电子邮件电子邮件系统的两种实体为用户代理以及邮件服务器。用户代理 (User Agent, UA)用户代理是用户与电子邮件系统的接口，即电子邮件客户端软件。其功能有撰写、显示、处理和通信。邮件服务器邮件服务器用于发送和接收邮件，并向发送人报告传送信息，如已交付、被拒绝或丢失等。邮件服务器按照客户/服务器方式工作，即一个邮件服务器可以作为客户，也可以作为服务器。邮件服务器发送邮件使用 SMTP 协议，而客户端读取邮件则使用 POP3 协议。简单邮件传送协议 SMTPSMTP 为发送邮件的协议，其全称为 Simple Mail Transfer Protocol。RFC 2821 (前为 RFC 821)：Simple Mail Transfer ProtocolSMTP 规定了两个相互通信的 SMTP 进程之间应该如何交换信息。SMTP 使用客户/服务器的方式工作，负责发送邮件的 SMTP 进程为 SMTP 客户，而负责接收邮件的 SMTP 进程为 STMP 服务器。SMTP 定义了 14 条命令和 21 种应答信息。每条命令用 4 个字母组成，而每一种应答信息则一般只有一行信息，由一个 3 位数字的代码开始，后面可视情况附上简单的文字说明。SMTP 通信的三个阶段为连接建立、邮件传送以及连接释放。连接建立连接在发送主机的 SMTP 客户和接收主机的 SMTP 服务器之间建立，不使用中间邮件服务器。连接释放邮件发送完毕后，SMTP 释放 TCP 连接。电子邮件的信息格式RFC 2822 (前为 RFC 822)：Internet Message Format一个电子邮件分为信封和内容两大部分。RFC 822 只规定了邮件内容中的首部格式，而邮体的主体部分则由用户自由撰写。首部中的主要字段如下： To：后面填入一个或多个收件人的 e-mail 地址 Subject：邮件的主题，反映了邮件的主要内容 Cc：抄送，表示给某人发送一个邮体副本 From：发信人的电子邮件地址 Date：发信日期 Reply-to：对方回信地址MIME早期的邮件仅支持 7bit ASCII 编码，导致传送非英语信息时存在困难。因此 1993 年提出了 MIME 标准。MIME 的全称为 Multi-purpose Internet Mail Extension。MIME 标准通过在邮件首部中说明数据类型，如文本、声音、图像、视像等，可在邮件传送多种类型的数据。读取邮件的协议为 Post Office Protocol, POP3 和 Internet Message Access Protocol, IMAP。MIME 的思路如下： 继续使用目前的 RFC 822 格式 对二进制数据进行编码，将其转换为 7 位 ASCII 码 邮件首部中增加字段，定义数据类型和编码规则MIME 新增的 5 种头部字段如下： MIME-Version：MIME 版本号，一般为 1.0 Content-Type：报文体中数据的类型 Content-Transfer-Encoding：传输时编码格式 Content-ID：唯一的标识符 Content-Description：供人阅读的内容描述传统的编码规则有： base64：又称为基数 64 转换 (Radix-64)，原始二进制数据中的每 6bit 被映射为 8bit，即 ASCII 字符。 quoted-printable：原始二进制数据的 8bit 表示为 2 个 16 进制数，并前加 = 符号。" }, { "title": "传输层 Transport Layer", "url": "/posts/%E4%BC%A0%E8%BE%93%E5%B1%82-Transport-Layer/", "categories": "Notes, Computer Network", "tags": "Computer Network", "date": "2022-04-16 16:36:00 +0800", "snippet": "传输层协议概述传输层 (Transport layer) 又称运输层。传输层向它上面的应用层提供通信服务，即实现可靠传输，其中包括差错控制、顺序控制、拥塞控制等。网络层实现主机之间的逻辑通信。而传输层则实现应用进程之间的逻辑通信，实现真正的端到端通信，即应用进程之间的通信。在一台主机中经常有多个应用进程同时分别和另一台主机中的多个应用进程通信。这表明传输层有一个很重要的功能，复用 (multiplexing) 和分用 (demultiplexing)。传输层的两个主要协议传输层主要的协议有 TCP 协议（可靠的传输协议）以及 UDP 协议（不可靠的传输协议）。按照 OSI 的术语，传输的数据单位称为运输协议数据单元 (Transport Protocol Data Unit, TPDU)。但在 TCP/IP 体系中，则根据所使用的协议是 TCP 或 UDP，分别称之为 TCP 报文段 (segment) 或 UDP 用户数据报。Transmission Control Protocol, TCP 协议是可靠的传输协议，其提供面向连接的服务。在传送数据之前，必须先建立连接，传送结束后要释放连接。由于 TCP 要提供可靠的、面向连接的传输服务，因此不可避免地增加了许多的开销，如确认、流量控制、计时器以及连接管理等。基于 TCP 的典型应用协议有 HTTP、FTP、…User Datagram Protocol, UDP 协议是不可靠的传输协议，传输数据之前不需要先建立连接。与 TCP 相比，其效率更高，但可能出现数据错误、丢包以及顺序错误等问题。基于 UDP 的典型应用协议有 DNS、RIP、…传输层的接口应用层多个应用进程通过传输层发送数据，这就是复用。传输层收到的数据必须交付给指明的应用程序，这就是分用。传输层必须提供区分上层应用程序的手段，这就是协议端口 (protocol port)，简称为端口 (port)。这种在协议栈层间的抽象的协议端口是软件端口，和路由器或交换机上的硬件端口是完全不同的概念。硬件端口是不同硬件设备进行交互的接口，而软件端口是应用层的各种协议进程与传输实体进行层交互的地点。TCP/IP 协议使用 16 位整数作为端口号，但端口号只具有本地意义，只是为了标志本计算机应用层中的各个进程在和传输层交互时的层间接口。Port 0 ~ 1023熟知 (well-known) 端口号或系统端口号，如 HTTP 服务使用 80，FTP 服务使用 21 等。Port 1024-49151登记端口号，供没有熟知端口号的应用程序使用，必须在 IANA 登记，以防止重复。Port 49152 ~ 65535客户端口号或短暂端口号，供客户进程临时使用。用户数据报协议 UDPUDP 只在 IP 的数据报服务之上增加了很少一点的功能，即端口和差错检测。其为不可靠传输协议，但具有自身特点，与 TCP 分别面对不同的应用。UDP 协议的特点有： 无连接，即发送数据之前不需要建立连接 使用尽最大努力交付，即不保证可靠交付，同时也不使用拥塞控制 是面向报文的 没有拥塞控制，很适合多媒体通信的要求 支持一对一、一对多、多对一和多对多的交互通信 首部开销小，只有 8 个字节UDP 首部格式IP 首部的协议字段为 17 时，数据为 UDP 的报文段。UDP 数据报包括 2 个字段，即首部和数据字段。首部共有 4 个字段，8 个字节。各字段分别为： 源端口，2 个字节，表示源端口号 目的端口，2 个字节，表示目的端口号 长度，2 个字节，表示 UDP 数据报的长度 校验和。2 个字节，表示 UDP 数据报的校验和UDP 计算校验和UDP 计算检验和的方法和计算 IP 数据报首部检验和的方法相似。但不同的是 IP 数据报的检验和只检验 IP 数据报的首部，但 UDP 的检验和是把首部和数据部分一起都检验。传输控制协议 TCPTCP 主要的特点有： TCP 是面向连接的传输层协议，即传输数据前必须先建立连接，数据传输完后要释放连接 每一条 TCP 连接只能有两个端点 (endpoint)，每一条 TCP 连接只能是点对点、一对一的 TCP 提供可靠交付的服务，即无差错、不丢失、不重复、按序到达 TCP 提供全双工通信，即在一个连接上，通信双方可同时向对方传输数据 面向字节流，这里的流指的是流入到进程或从进程流出的字节序列。应用程序以数据块为单位与 TCP 交互，但 TCP 将其视为无结构的字节流。这导致发送方应用程序发出的数据块与接收方应用进程收到的数据块可能没有一一对应关系，但数据保一致。需要注意的是，TCP 连接是一条虚拟连接，而不是一条真正的物理连接。TCP 对应用进程一次把多长的报文发送到 TCP 的缓存中是不关心的。TCP 会根据对方给出的窗口值和当前网络的拥塞程度来决定一个报文段应该包含多少个字节，而不是像 UDP 发送的报文长度是由应用程序给出的。其可以把太长的数据块划分短一些再传送，也可以等累计到有足够多的字节后再构成报文段发送出去。TCP 的连接TCP 把连接作为最基本的抽象。每一条 TCP 连接都有两个端点，TCP 连接的端点不是主机，不是主机的 IP 地址，不是应用进程，也不是传输层的协议端口。TCP 连接的端点叫做套接字 (socket) 或插口。端口号拼接到 (contatenated with) IP 地址即扣成了套接字 套接字 socket ::= (IP 地址 : 端口号)每一条 TCP 连接唯一地被通信两端的两个端点所确定，即： TCP 连接 ::= {socket1, socket2} = {(IP1: port1), (IP2: port2)}TCP 报文段的首部格式IP 首部的协议字段为 06 时，数据为 TCP 的报文段。TCP 报文段首部有 20 个字节是固定的，后面有 $4n$ 字节是根据需要而增加的选项。因此 TCP 首部的最小长度是 20 字节。源端口 Source port2 字节，源端口。目的端口 Destination port2 字节，目的端口。序号字段 Sequence number4 字节，在 TCP 连接中传输的数据流中的每一个字节都有序号。序号字段指本报文段所发送的数据的第一个字节的序号，以字节为单位。确认号字段 Acknowledgement number4 字节， 期望收到对方的下一个报文段的数据的第一个字节的序号。TCP 连接是全双工，即通信双方可互相发送数据，因此应答与数据一同发送给对方。若收到对方的报文段中序号为 501，数据长度为 200 字节，则返回报文段确认号 701。首部长度/数据便宜 TCP header length4 位，TCP 报文段的数据起始位置的偏移，也就是首部的长度，单位是 32 位字（4 字节）。紧急 URG1 位，为 1 时，紧急指针字段有效，表明有紧急数据，应尽快传送。确认 ACK1 位，为 1 时，确认号字段有效。推送 PSH1 位，为 1 时，接收方将尽快向应用进程交付此报文段，而不是等整个缓存填满。复位 RST1 位，为 1 时，表明 TCP 连接出现严重差错，必须释放连接后重新建立连接。同步 SYN1 位，为 1 时，表示这是一个连接请求或连接接受报文。终止 FIN1 位，为 1 时，表示要求释放 TCP 连接。窗口大小 Window size2 字节，用来让对方设置发送窗口的依据，单位时字节。校验和 Checksum伪首部 + 首部 + 数据的校验和，伪首部格式与 UDP 的伪首部相同。紧急指针 Urgent pointer2 字节，指出本报文段中紧急数据共有多少个字节，紧急数据放在数据的最前面。选项 Options长度可变，最长 40 字节。最早定义的一种选项为最大报文段长度 (Maximum Segment Size, MSS)，用以告知对方报文段中数据的最大长度，双方可使用不同的 MSS，缺省 MSS = 536 字节。后续增加的选项有窗口扩大选项、时间戳选项、选择确认选项等。填充字段为了使整个首部长度为 4 字节的整数倍。TCP可靠传输的实现TCP 基于滑动窗口协议实现可靠传输和流量控制，滑动窗口以字节为单位。以字节为单位的滑动窗口发送窗口在没有收到对方应答的情况下，可以连续把窗口内的数据发送出去。窗口大小是由对方发来的窗口大小、拥塞控制确定的，而不总是一样大。窗口会根据收到对方的 TCP 报文段头部中的确认号字段向前滑动。接收窗口窗口内的数据是允许接收的。而窗口后沿以外是已正确接受并交付上层的数据。TCP 要求接收方必须要有累计确认的功能，这样可减少传输开销。发送缓存用以暂时存放： 发送应用进程传送给 TCP，但仍未发出的数据 已经发出，但仍未得到确认的数据接受缓存用以暂时存放： 按序到达的、但仍未被接收应用进程读取的数据 未按序到达的数据超时重传时间的选择TCP 的可靠传输通过校验和+超时重传实现。TCP 每发送一个报文段，就会对该报文段设置一个计时器。若计时器设置的重传时间到，却没有收到确认，就需重传该报文段。超时时间的设置是一个复杂的问题，因为 IP 层提供数据报服务时，每个数据报所选择的路由都有可能发生变化，这就导致传输层的往返时间变化较大。为此，TCP 采用一种自适应算法计算超时重传时间，即加权平均往返时间 $RTT_S$。当第一次测量到 $RTT$ 时，$RTT_S$ 值就取为所测量到的 $RTT$ 样本值。但以后每测量到一个新的 $RTT$ 样本，就按以下公式重新计算一次 $RTT_S$。 新的 $RTT_S = (1-\\alpha) \\times (旧的 RTT_S)+\\alpha \\times (新的 RTT 样本)$在以上公式中，$0\\le \\alpha \\lt 1$。若 $\\alpha$ 很接近于零，标示新的 $RTT_S$ 值与旧的 $RTT_S$ 值相比变化不大，对新的 $RTT$ 样本影响也不大。若选择 $\\alpha$ 接近于 $1$，则表示新的 $RTT_S$ 值收新的 $RTT$ 样本的影响较大。已成为建立标准的 RFC 6298 推荐的 $\\alpha$ 值为 1/8，即 0.125。超时重传时间 (Retransmission Time-Out, RTO)RTO 应该要略大于 $RTT_S$。RFC 6298 建议使用以下公式计算 RTO。 $RTO=RTT_S+4\\times RTT_D$而 $RTT_D$ 是 RTT 的偏差的加权平均值，它与 $RTT_S$ 和新的 RTT 样本之差有关。RFC 6298 建议这样计算 $RTT_D$。当第一次测量时，$RTT_D$ 值取为测量到的 RTT 样本值的一半。但以后的测量中，则使用以下公式计算加权平均的 $RTT_D$。 $新的RTT_D=(1-\\beta)\\times (旧的 RTT_D)+\\beta \\times \\mid RTT_S-新的 RTT 样本\\mid$这里 $\\beta$ 是个小于 1 的系数，它的推荐值是 1.4，即 0.25。TCP 的流量控制流量控制是让发送方的发送速率不要太快，使接收方来得及接收。利用滑动窗口机制可以很方便地在 TCP 连接上实现流量控制。持续计时器 (persistence timer)TCP 为每一个连接设有一个持续计时器。只要一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到，就发送一个零窗口探测报文段，而对方在确认这个探测报文段时给出当前窗口值。若窗口值仍然为零，则收到这个报文段的一方就重新设置持续计时器。若窗口值不为零，则死锁的僵局就可以打破了。传输效率可以用不同的机制来控制 TCP 报文段的发送时机。机制一：缓存数据达到一定量就发送TCP 维持一个变量，该变量等于最大报文段长度 MSS。只要缓存中存放的数据达到 MSS 字节时，就组装成一个 TCP 报文段发送出去。机制二：应用进程控制由发送方的应用进程指明要求发送报文段，即推送 (push) 操作。机制三：定时发送发送方的一个计时器期限到了，这时就把当前已有的缓存数据装入长度不超过 MSS 的报文段发送出去。TCP 的拥塞控制在某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络的性能就会变坏，从而产生拥塞。出现网络拥塞的条件如下： $\\sum 对资源的需求 \\gt 可用资源$其中网络资源包括链路带宽、路由节点缓存及处理能力等。拥塞的产生原因网络拥塞往往是由多种因素引起的。如某路由器缓存容量太小，造成到达该节点的报文丢失。假设增加了缓存容量，报文可以在缓存中排队，但如果路由器的处理能力和出口链路带宽未增加，则报文排队时间过长，发送的主机将超时重发。因此简单扩大缓存并不能解决网络拥塞的问题，反而还会造成网络资源的严重浪费。网络拥塞会导致网络性能下降，具体表现为网络吞吐率下降、报文传输时延增大、丢包率增加以及用户端响应时间变长等。而且网络拥塞常常会趋于恶化。如一个路由器因缓存空间不足而丢弃了部分报文，发送端主机将超时重发，导致网络中被注入更多的报文，从而加剧了拥塞。拥塞控制与流量控制所谓拥塞控制，就是防止过多的数据注入到网络中，使网络中的路由器或链路不至于过载。拥塞控制是一个全局性的过程，涉及所有的主机、路由器，以及与降低网络传输性能有关的所有因素。相反的，流量控制往往是指点对点通信量的控制，是端到端的问题。流量控制所要做的就是抑制发送端发送数据的速率，以便接收端来的及接收。开环控制开环控制是在设计网络时事先将有关发生拥塞的因素考虑周到，力求网络在工作时不产生拥塞。闭环控制闭环控制则是基于反馈环路的概念，主要有以下几种措施： 监测网络系统以便检测到拥塞在何时、何处发生 将拥塞发生的信息传送到可采取行动的地方 调整网络系统的运行以解决出现的问题如何判断是否发生拥塞拥塞发生时，路由器将丢弃分组。简单的主机端判断方式是，只要没有收到确认，就认为发生了拥塞。拥塞控制方法RFC 2581 中定义了四种拥塞控制的方法，即： 慢启动 (slow-start)，又称为慢开始 拥塞避免 (congestion avoidance) 快重传 (fast retransmit) 快恢复 (fast recovery)慢启动/慢开始 (slow-start)当主机在已建立的 TCP 连接上开始发送数据时，并不清楚网络当前的负荷情况。如果立即把大量数据注入网络，可能会导致拥塞。因此较好的方法是先探测一下，即由小到大逐渐增大注入到网络中的数据字节，也就是由小到大逐渐增大拥塞窗口数值。工作过程开始发送报文段时，设置拥塞窗口 cwnd = 1，即设置为一个最大报文段 MSS 的数值。之后每收到一个对新的报文段的确认后，将拥塞窗口加 1，即增加一个 MSS 的数值。用这样的方法逐步增大发送端的拥塞窗口 cwnd，可以使分组注入到网络的速率更加合理。拥塞窗口 (congestion window, cwnd)由发送方维持拥塞窗口，是一个状态变量。其大小取决于网络等于拥塞窗口，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口，如再考虑到接收方的接收能力，则发送窗口可能小于拥塞窗口。只要没有出现拥塞，拥塞窗口就增大一些，以便把更多的分组发送出去。一旦出现拥塞，拥塞窗口就缩小一些，以减少注入到网络中的分组数。传输轮次 transmission round使用慢启动时，每经过一个传输轮次，拥塞窗口 cwnd 就会加倍。一次传输轮次所经历的时间就是往返时间 RTT。这里强调把拥塞窗口 cwnd 所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。慢启动门限 ssthresh为防止拥塞窗口 cwnd 增常过大而导致拥塞，就设置一个慢启动门限。当 cwnd &lt; ssthresh 时，使用慢启动算法。当 cwnd &gt; ssthresh 时，停止使用慢启动算法，改用拥塞避免算法。当 cwnd = ssthresh 时，可使用慢启动算法或拥塞避免算法。拥塞避免 (congestion avoidance)拥塞避免就是让拥塞窗口 cwnd 缓慢地增大，即每经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd 加 1，而不是加倍，使拥塞窗口 cwnd 按线性规律缓慢增长。无论在慢启动阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞，就要把慢启动门限 ssthresh 改为出现拥塞时的发送方窗口值的一半，但不能小于 2。然后把拥塞窗口 cwnd 重新设置为 1，执行慢启动算法。这样可迅速减少注入到网络中的分组数，使得发生拥塞的路由器有足够的时间把队列中积压的分组处理完毕。乘法减小 multiplicative decrease无论在慢启动阶段还是拥塞避免阶段，只要出现一次超时，就把慢启动门限 ssthresh 减小到拥塞窗口的一半。这样当网络频繁出现拥塞时，ssthresh 值下降得很快，以大大减少注入到网络中的分组数。加法增大 additive increase执行拥塞避免算法后，每经过一个往返时间 RTT，把拥塞窗口 cwnd 增加一个 MSS 大小，使拥塞窗口缓慢增大，以防止网络过早出现拥塞。快重传 (fast retransmit)如果发送方在超时时间内未收到确认报文，说明网络中发生了拥塞，此时发送方应该尽早减少窗口宽度。每当接收方收到一个失序的报文段，就发出重复确认，以便使发送方及早知道有报文段没有到达接收方。发送方只要连续收到三个重复确认，就应该立即重传对方尚未收到的报文段。快恢复 (fast recovery)当发送端收到连续三个重复的确认时，进行乘法减小，把慢启动门限 ssthresh 减为当前拥塞窗口宽度的一半。接下来不执行慢启动算法，而是设置为慢启动门限 ssthresh 减半后的数值，然后开始执行拥塞避免算法，使拥塞窗口缓慢地线性增大。发送窗口的上限值从流量控制角度考虑，发送窗口不能超过对方给出的接收窗口值。综合考虑流量控制和拥塞控制，发送方的发送窗口的上限值应当在接收方窗口 rwnd 和拥塞窗口 cwnd 两者中取较小的一个，即发送窗口的上限值 = min[rwnd, cwnd]。当 rwnd &lt; cwnd 时，是接收方的接收能力限制发送窗口的最大值。当 rwnd &gt; cwnd 时，则是网络的拥塞限制发送窗口的最大值。TCP 的连接管理TCP 传输连接有三个阶段，即连接建立、数据传送以及连接释放。连接建立的过程中需要解决的三个问题有： 使每一方能够确知对方的存在 允许双方协商一些参数，如最大报文段长度、最大窗口大小以及服务质量等。 能够对传输实体资源进行分配，如缓存、连接表中的项目等。TCP 连接的建立都是采用客户/服务器方式。客服 (client) 指的是主动发起连接建立的应用程序。而服务器 (server) 则指被动等待连接建立的应用程序。TCP 的连接建立TCP 连接的建立采用三次握手 (three-way handshake)： A 向 B 发出连接请求报文段，其首部中的 SYN = 1，并选择序号 seq = x，表明传送数据时的第一个数据字节的序号是 x。 B 收到连接请求后，如同意，则发回确认，其中 SYN = 1，ACK = 1，确认号 ack = x + 1，自己选择的序号seq = y。 A 收到后向 B 给出确认，其 ACK = 1，确认号 ack = y + 1。 B 收到后，TCP 连接成功建立。为什么采用 3 次握手采用 3 次握手是为了防止失效的连接请求在服务器端占用资源。假设客户端发出了连接请求，但该数据报在网络中某处滞留了。客户端等待超时后，重发连接请求，服务器响应，建立连接。滞留的连接请求又到了服务器端，如果采用 2 次握手，服务器将建立一个连接，分配资源，这会占用资源且长期存活。3 次握手的安全问题TCP SYN Flooding 攻击，即攻击者连续发送大量 SYN 报文，但却不对 SYN ACK 报文做出响应。这导致服务器内部数据结构满，无法响应正常用户的 TCP 连接请求。此类攻击大多使用 IP 地址伪装，使得对攻击源的定位比较困难。Linux 内核采用了 SYN_Cookies 机制应对这种攻击。其思路是，服务器返回 SYN ACK时，根据自身特有信息计算Cookies，作为 seq 返回给客户端，并在收到对方应答前，不为该连接分配数据结构。TCP 的连接释放报文段最大存活时间 (Maximum Segment Lifetime, MSL)RFC 793 中建议 MSL = 2 分钟，一般使用更小的值。关闭连接前，等待 2MSL 时间的原因是为了保证 A 发送的最后一个 ACK 报文段能够到达 B，同时防止已失效的连接请求报文段出现在本连接中。" }, { "title": "网络层 Network Layer", "url": "/posts/%E7%BD%91%E7%BB%9C%E5%B1%82-Network-Layer/", "categories": "Notes, Computer Network", "tags": "Computer Network", "date": "2022-03-25 16:36:00 +0800", "snippet": "网络层提供的两种服务网络层应该向运输层提供这样的服务，曾引起了长期的争论。争论焦点的实质是：数据的可靠传输应该由网络还是端系统来负责？面向连接面向连接的服务，即虚电路 (virtual circuit)。虚电路只是一种逻辑连接，分组沿着这条逻辑连接按照存储转发方式传送，而非真正建立一条物理连接。在两台计算机进行通信时，先由网络建立连接，之后的数据均通过该连接进行，由网络保证数据传输的可靠性。其支持方以电信公司为代表。无连接无连接的服务，即数据报 (datagram)。网络在发送数据时，不需要先建立连接，每个分组在网络中独立传送，与其前后的分组无关。网络层不保证服务质量，分组可能出错、丢失、重复和失序，也不保证分组传送的时限。其支持方以 Internet 为代表，TCP/IP 就是采用数据报服务。网际协议 IP网际协议 IP 是 TCP/IP 体系中两个最重要的协议之一。与 IP 协议配套使用的还有四个协议： 地址解析协议 (Address Resolution Protocol, ARP) 逆地址解析协议 (Reverse Address Resolution Protocol, RARP)，已淘汰不使用了 网际控制报文协议 (Internet Control Message Protocol, ICMP) 网际组管理协议 (Internet Group Management Protocol, IGMP)分类的 IP 地址IP 地址是给连接到互联网上的每一台主机的每一个接口，分配一个在全世界范围内是唯一的 32 位标识符。IP 地址现在由互联网名字和数字分配机构 (Internet Corporation for Assigned Names and Numbers, ICANN) 进行分配。IP 地址被分为 A, B, C, D, E 五类，每一类地址都包含网络号以及主机号两个字段。其表示方法为点分十进制记法 (dotted decimal notation)。曾经 B 类地址中的网络地址 128.0.0.0 和 C 类地址中的网络地址 192.0.0.0 都是规定不指派的，但现在都可以指派了。其中还有一些有特殊含义的 IP 地址，像是全 0 表示本网络或本主机的 IP 地址、全 1 表示广播地址的 IP 地址以及网路号为 127 用于本地软件环回测试的 IP 地址。IP 地址与硬件地址物理地址数据链路层和物理层使用的地址，被存放在数据链路层的帧中。IP 地址网络层和以上各层使用的地址，是一种逻辑地址，被存放在 IP 包头部。ARP 与 RARP 协议ARP协议 (Address Resolution Protocol)全称为 RFC 826: An Ethernet Address Resolution Protocol。每一台主机都设有一个 ARP 高速缓存 (ARP cache)，里面有本局域网上的各主机和路由器的 IP 地址到硬件地址的映射表。ARP 解决同一局域网中的主机或路由器的 IP 地址和硬件地址的映射问题。如果目的主机不在本局域网内，IP 包就需要经由路由器转发。此时在局域网内要完成的是路由器 IP 与物理地址的映射。RARP协议 (Reversed Address Resolution Protocol)旧协议，作用是使只知道自己硬件地址的主机能够通过 RARP 协议找出其 IP 地址。现在的 DHCP 协议已经包含了 RARP 协议的功能。IP 数据报格式版本 Version4bit，IP 协议的版本，目前的 IP 协议版本号为 4，即 IPv4。首部长度 IHL4bit，IP 包头长度，最小 5，最大 15，单位为 word (32bit)。区分服务 Type of Service1字节，服务类型，目前很多路由器忽略该字段。总长度 Total Length2字节，IP包总长度，包含头部和数据，单位为字节。标识 Identification2字节，是一个计数器，用以产生 IP 包的标识。当一个 IP 包超过数据链路层 MTU 时，就需要分片传输。分片的多个包具有相同的标识，便于接收端重组。标志 Flag3bit，目前只使用两个Flag，分别是： 1bit, Don’t Fragment, DF。当 DF = 0 时允许分片。 1bit, More Fragment, MF。当 MF = 1 时表示后面还有分片，而 MF = 0 则表示最后一片。片偏移 Fragment Offset13bit，片偏移，较长的包在分片后，某片在原分组中的相对位置，以 8 字节为单位。生存时间 Time To Live1字节，生存时间，IP 包在网络中可通过的路由器个数的最大值。IP 包每经过一个路由器则 TTL 减 1，TTL 为 0 时就丢弃，并向源主机发送一个告警包。Windows 操作系统一般为 128，UNIX 操作系统一般为 255，Linux 一般为 64。协议 Protocol8bit，协议字段，指出此数据报携带的数据是使用什么协议，以便使目的主机的 IP 层知道应该将数据部分上交给哪个协议进行处理。首部校验和 Header checksum2字节，只检验数据报的首部，不包括数据部分。源地址 Source address4字节，源 IP 地址。目标地址 Destination address4字节，目的 IP 地址。校验和算法对 IP 包头，每 16 位求反，循环相加，和再求反。若结果为 0 则保留。否则丢弃该数据报。划分子网和构造超网由于 ARPANET 早期，IP 地址的设计不够合理。 分类 IP 地址无法适应 Internet 快速发展的需要，每个 A 类地址的主机数超过 1000 万，B 类地址也超过 6 万。有的单位申请了一个 B 类地址网络，连接的主机数却不多，导致 IP 地址空间的利用率有时很低，造成 IP 地址的浪费，还会使得 IP 地址空间的资源过早被用完。 为每一个物理网络分配一个网络号会使路由表变得太大，因而使网络性能变坏。 两级 IP 地址不够灵活。有些情况下，一个单位需要在新的地点马上开通一个新的网络。但在申请到一个新的 IP 地址之前，新增加的网络是不可能连接到互联网上工作的。而我们希望的是，一个单位能随时灵活的增加本单位的网络，不必事先到互联网管理机构去申请新的网络号。这是两级 IP 地址无法做到的。为了解决上述问题，就在 IP 地址中增加了一个子网号字段，使两级 IP 地址变为三级 IP 地址，就能较好地解决上述问题，使用起来也更灵活。而这就是划分子网。划分子网基本思想一个拥有多个物理网络的单位可按照物理网络划分为若干个子网 (subnet)。划分子网的方法是从网络的主机号借用若干位作为子网号 (subnet-id)。因此两级 IP 地址在本单位内部就变为了三级 IP 地址。 原来的 IP 地址 ::= 网络号，主机号 变为了 IP 地址 ::= 网络号，子网号，主机号其他网络发来的 IP 数据报，仍然根据 IP 数据报的目的网络号 net-id，找到本网络的路由器。此路由器收到 IP 数据报后，再按照目的网络号 net-id 和子网号 subnet-id 找到目的子网。子网掩码从 IP 数据报的首部无法看出源主机或目的主机所连接的网络是否进行了子网的划分，这是因为 32 位的 IP 地址本身以及数据报的首部都没有包含任何有关子网划分的信息。因此就有了子网掩码。子网掩码是一个网络或一个子网的重要属性，在路由寻址中发挥着重要作用。使用子网掩码的好处是，不管网络有没有划分子网，只要把子网掩码和目的 IP 地址进行逐位的与运算，就能立即得出子网网络地址。使用子网掩码的分组转发过程使用子网划分后，路由表必须包含以下三项基本信息：目的网络地址、子网掩码和下一跳地址。在划分子网的情况下，路由器的转发流程如下： 从收到的分组的首部提取目的 IP 地址 D。 先用与该路由器直接相连各网络的子网掩码与 D 逐位相与，看是否和相应的网络地址匹配。若匹配，则将分组直接交付。否则就间接交付，执行 3。 若路由表中有目的地址为 D 的特定主机路由，则将分组传送给指明的下一跳路由器。否则执行 4。 对路由表中的每一行的子网掩码与 D 逐位相与，若其结果与该行的目的网络地址匹配，则将分组传送给该行指明的下一跳路由器。否则执行 5。 若路由表中有一个默认路由，则将分组传送给路由表中所指明的默认路由器。否则执行 6。 报告中转发分组出错。其核心操作是将目的 IP 地址与路由表中子网掩码相与，并判断是否与目的网络地址匹配。主机发送数据报时判断目的地址是否在本地子网的方法if ((目的地址 &amp; subnet mask) == (主机地址 &amp; subnet mask)) 目的地址在本地子网，直接交付else 数据报发往gatewayend if路由器查找路由表进行表项匹配的过程if ((目的地址 &amp; subnet mask) == 目的网络地址) 数据包发往该表项的网络出口end if在子网内直接交付过程查找 ARP 缓存，是否有目的 IP 地址对应的 MAC 地址if (目的 MAC 地址在 ARP 缓存中) 将 IP 数据包封装成帧后，在局域网内向目的 MAC 地址直接发送帧else 在子网内广播发送 ARP 请求，目的主机收到请求后返回 ARP 应答，由此得知目的主机 MAC 地址end if无分类编制 CIDR全称为 Classless Inter-Domain Routing。其主要特点有： 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念。 使用各种长度的网络前缀，来代替分类地址中过的网络号和子网号。 IP 地址从三级编址回到了两级编址，IP 地址 ::= 网络前缀，主机号 使用斜线记法 (slash notation)，又称 CIDR 记法，即在 IP 地址后加一个斜线，后跟网络前缀所占的位数，如 128.14.35.7/20 表示该地址的高 20 位是网络前缀。 网络前缀都相同的连续的 IP 地址组成 CIDR 地址块，如 128.14.32.0/20 表示的 CIDR 地址块就有 $2^{12}$ 个地址，从 128.14.32.0 至 128.14.47.255。路由聚合 (route aggregation)由于一个 CIDR 地址块中有很多地址，所以在路由表中就利用 CIDR 地址块来查找目的网络。这种地址的聚合常称为路由聚合，它使得路由表中的一个项目可以表示原来传统分类地址的很多个路由，可以减少路由表中的表项个数，并减少路由器之间交换的路由信息量。路由聚合也称为构成超网 (supernetting)，这是因为 CIDR地址块大多包含多个 C 类地址。地址掩码CIDR 不使用子网，但仍使用地址掩码这个名词。如 /20 的地址掩码为：11111111 11111111 11110000 00000000。最长前缀匹配最长前缀匹配又称为最长匹配或最佳匹配。对于查找路由表时的匹配结果，应该从中选择具有最长前缀匹配的路由。这是因为网络前缀越长，其地址块就越小，因而路由就越具体。国际控制报文协议 ICMP全称为 RFC 792 : Internet Control Message Protocol，主要用于报告出错和测试等控制信息。ICMP 位于 IP 层，ICMP 报文是装在 IP 数据报中，作为其中的数据部分传输的。ICMP 报文的种类ICMP 报文的种类有两种，即 ICMP 差错报告报文和 ICMP 询问报文。差错报告报文有：终点不可达 Destination unreachable路由器或主机无法传输报文时，向源主机发送此报文。源点抑制 Source quench路由器或主机由于拥塞丢弃报文时，向源主机发送此报文，使其放慢发送速度。超时 Time exceeded路由器收到 TTL 字段为 0 的报文时，向源主机发送此报文。参数问题 Parameter problem路由器或主机收到的报文中，头部有非法字段时，丢弃数据报，并向源主机发送此报文。改变路由 Redirect路由器向主机发送此报文，告知路由改变，主机下次发送数据报给另外的路由器。询问报文有：回送请求或回答 Echo request/reply用于测试网络连通性。时间戳请求或回答 Timestamp request/reply用于时间同步。ICMP 的应用举例分组网间探测 Ping全称为 Packet Internet Groper，其采用 ICMP Echo request/reply 报文，用以测试两台主机之间的连通性。Ping 是应用层直接使用网络层 ICMP 的一个例子，没有通过运输层的 TCP 或 UDP。Traceroute / Tracert采用 ICMP 超时报告报文，用以测试到另一台主机所经过的路由信息。其方法是逐个发出 UDP 报文，其 IP 包头中的 TTL 字段分别设为 1, 2, 3, …，直到到达目的主机。报文路由路径上的路由器会返回 ICMP 超时报文，从该报文即可得知路由器 IP 地址。路由算法及协议在网络中，路由器依据路由信息（路由表）转发分组，路由信息是路由协议生成的，路由算法是路由协议的基础和核心。理想的路由算法应该具备的特性有： 必须是正确和完整的，即按照得出的路由能够进行正确寻址。 在计算上应该简单，不增加过多开销。 有自适应性，即能根据通信量和网络拓扑的变化调整路由。 应该具有稳定性，即通信量和拓扑稳定时，能快速收敛。 应该是公平的，即对所有用户都公平。 应该是最佳的，即能找出最好的路由，指的是时延最小、吞吐量最大的路由。但不同情况下的路由需求可能各有侧重，且网络环境不断变化，因此不存在一种绝对的最佳路由算法。静态路由与动态路由静态路由静态路由的选择策略为非自适应路由选择。此选择策略简单和开销较小，但不能及时适应网络状态的变化。因此适用于小规模且变化较少的网络，由人工设置路由。动态路由动态路由的选择策略为自适应路由选择。此选择策略能较好地适应网络状态的变化，但实现起来较为复杂，开销也比较大。因此适用于较大规模、频繁变化的网络，通过专门的算法和协议进行路由的计算。两类典型的动态路由算法为距离向量 (distance vector) 路由算法以及链路状态 (link state) 路由算法。距离向量路由 (distance vector routing)也称为 Bellman-Ford 路由算法和 Ford-Fulkerson 算法。最初用于 ARPANET，被 RIP 协议采用。其基本思想是，每个路由器维护一张表，表中给出了到每个目的地的已知最佳距离和线路，并通过与相邻路由器交换距离信息来更新表。路由器会周期性地向所有相邻路由器发送它的距离表，同时也接受每个邻居结点发来的距离表。相邻路由器 $X$ 发来的表中，$X$ 到路由器 $i$ 的距离为 $X_i$，本路由器到 $X$ 的距离为 $m$，则路由器经过 $X$ 到 $i$ 的距离为 $X_i + m$。根据不同邻居发来的信息，计算 $X_i + m$，并取最小值，更新本路由器的路由表。此算法的缺陷是无穷计算问题，即对好消息反应迅速，对坏消息反应迟钝。链路状态路由 (link state routing)每个路由器都需要完成 5 步工作： 发现它的邻居结点，并学习其网络地址。 测量到各邻居结点的延迟或开销。 构造一个分组，其中包含所有它刚刚知道的信息。 将这个分组发送给其他所有路由器。 计算出到每一个其他路由器的最短路径。各路由器之间动态交换链路状态信息，每个路由器都建立一个链路状态数据库。 链路状态，指本路由器都和哪些路由器相邻，以及该链路的度量 (metric)链路状态数据库实际上是全网的拓扑结构图，在全网范围内是一致的，即链路状态数据库的同步。各路由器根据网络拓扑，使用 Dijkstra 算法计算从本路由器到其他结点的最佳路径，构成路由表。Internet 采用分层次的路由Internet 规模庞大，任何一台路由器都不可能获取和存储整个 Internet 的路由信息。同时，接入 Internet 的众多网络（管理方）也不希望外界了解自己网络的内部信息。因此就有了自治系统 (Autonomous System, AS) 的概念。自治系统 (Autonomous System, AS)自治系统是指在单一的技术管理下的一组路由器，而这些路由器使用一种 AS 内部的路由选择协议和共同的度量以确定分组在该 AS 内的路由。同时还使用一种 AS 之间的路由选择协议，用以确定分组在 AS 之间的路由。一个 AS 可使用多种内部路由选择协议和度量，但对其他 AS 表现出的是单一和一只的路由选择策略。在自治系统的背景下，Internet 路由协议可分为两类，即：内部网关协议 (Interior Gateway Protocol, IGP)内部网关协议，是自治系统内部使用的路由选择协议。自治系统内部的路由选择又称为域内路由选择 (intradomain routing)。这类路由协议使用得最多，如 RIP 和 OSPF 协议。外部网关协议 (External Gateway Protocol, EGP)若源站和目的站处在不同的自治系统中，当数据报传到一个自治系统的边界时，就需要使用一种协议路由选择信息传递到另一个自治系统中，这样的协议就称为外部网关协议。自治系统之间的路由选择又称为域间路由选择 (interdomain routing)。应用最为广泛的外部网关协议为 BGP-4。Routing Information Protocol, RIP 协议其对应 RFC1058: Routing Information Protocol，属于距离向量路由协议。其特点是，简单，适用于小规模网络中的路由。RIP 中的距离定义是路由器条数 (hop count)。其最长距离为 15，即允许的最长路径中最多包含 15 个路由器，距离为 16 则表示不可达。RIP 协议的三个要点是： 仅和相邻路由器交换信息。 交换的信息是当前本路由器所知道的全部信息，即自己的路由表。 按固定的时间间隔交换路由信息，典型值为 30 秒。其优点有： 实现简单，开销较小，便于计算。其缺点有： 当网络出现故障时，要经过比较长的时间才能将此信息传送到所有路由器 支持的网络规模有限，最大距离为 15，距离为 16 则不可达。 路由器之间交换的路由信息是路由器中的完整路由表，随着网络规模的扩大，开销也会随之增加。RIP 报文格式Open Shortest Path First 协议其对应 RFC2328: OSPF Version 2，属于链路状态路由协议。OSPF 不用 UDP，而是直接用 IP 数据报传送。其优点有： 收敛速度快，即当链路状态发生变化时，结点会以洪泛 (flooding) 方式告知所有网络中的其他结点。 洪泛 (flooding) 是指结点收到分组时，向除输入链路外的所有其他链路发送出去。 适用于较大规模的网络，因为它仅在链路状态发生变化时才发送洪泛信息，就不会产生很大的通信量。为了管理大规模的网络，OSPF 将一个自治系统再划分为若干个区域。每个区域都有一个以点分十进制表示的 32 位区域标识符。OSPF 采用层次结构的区域划分，上层的区域称为主干区域 (backbone area)，主干区域的作用是用来连通其他在下层的区域。其标识符规定为 0.0.0.0。划分区域的好处是，利用洪泛法交换链路状态信息的范围局限在一个区域，而不是整个自治系统。这可以减少整个网络上的通信量。外部网关路由协议 BGPBGP 全称为 Border Gateway Protocol，是不同自治系统的路由器之间交换路由信息的协议。—————— 还有路由器 Router—————— 还有网络的控制平面与数据平面控制平面 (control plane)—————— 还有数据平面 (data plane)—————— 还有软件定义网络 (Software Defined Networking, SDN)—————— 还有IP 组播组播 (multicast)，又称多播，用于实现一点对多点的数据传输。对于一些网络应用，采用组播可以大大减少网络流量，如网络视频服务。组播数据报的目的地址写入的是组播组的标识符，然后设法让加入到这个组播组的主机的 IP 地址与组播组的标识符关联起来。组播组的标识符使用 D 类 IP 地址作为组播地址，D 类 IP 地址的前四位是 1110，因此 D 类地址范围是 224.0.0.0 到 239.255.255.255，并且 IP 包头中的协议字段值为 2，表示使用网际组管理协议 IGMP协议。组播可分为两种，一种是只在本局域网上进行硬件组播，另一种则是在互联网的范围进行组播。在局域网中的硬件组播这类组播是将 MAC 地址中的特定地址段作为组播地址，并与 IP 组播地址形成对应关系。在互联网范围的组播这类组播，路由器需要支持组播，即组播路由器。主机通过 IGMP 协议与组播路由器通信，加入或退出某个组播组。而组播路由器之间则通过组播路由协议实现组播数据报的传输。虚拟专用网 VPN 和网络地址转换 NAT网络地址转换 NATRFC 1918 定义了一些专用地址 (private address)： 10.0.0.0 ~ 10.255.255.255 (CIDR 记法为 10/8) 172.16.0.0 ~ 172.31.255.255 (CIDR 记法为 172.16/12) 192.168.0.0 ~ 192.168.255.255 (CIDR 记法为 192.168/16)这些地址只能用于一个机构的内部通信，而不能用于和互联网上的主机通信。互联网中的所有路由器，对目的地址为专用地址的数据报一律不进行转发。企业与机构内部网络使用专用地址的优点是可减少 IP 地址空间的占用，同时还可提高安全性。NAT 的基本工作原理是，当私有网的主机和公共网的主机通信的 IP 包经过 NAT 网关时，NAT 路由器会将 IP 包中的源 IP 或目的 IP 在私有 IP 和 NAT 的公共 IP 之间进行转换。NAT 路由器内部使用 TCP/UDP 端口号实现外网数据包向内网地址的转换。虚拟专用网 VPN有时一个很大的企业或机构的许多部门分布的范围很广，这些部门通常要互相交换信息，有两种实现方式： 租用专用线路，形成专用网。这种方法简单方便，但成本高昂。 利用公用的互联网作为本机构各专用网之间的通信载体，形成VPN。VPN 涉及的技术包括隧道 (tunnel)、加密、身份认证等。基于互联网建立 VPN 的两种情形有： 内部网络通过互联网互连，这可以采用 IPSec 的 ESP 隧道模式。 远程用户访问内部网 (remote access VPN)，其访问方式有拨号虚拟专用网 (Virtual Private Dialup Network, VPDN) 和基于 SSL 的 VPN 技术，后者的优点是客户端不需要额外安装或配置软件。通过公共网络传输的数据内容均经过加密，外部仅能通过 IP 分组头得知 R1 和 R2 在通信。" }, { "title": "数据链路层 Data Link Layer", "url": "/posts/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82-Data-Link-Layer/", "categories": "Notes, Computer Network", "tags": "Computer Network", "date": "2022-03-17 18:00:00 +0800", "snippet": "数据链路层设计要点数据链路层属于计算机网络的底层。物理层实现了比特流的传输，数据链路层在其基础上实现了帧 (frame) 的传输。数据链路层传输的协议数据单元 (Protocol Data Unit, PDU) 是帧。数据链路层把网络层交下来的数据构成帧发送到链路上，以及把接收到的帧中的数据取出并上交给网络层。数据链路层使用的信道类型点对点信道这种信道使用一对一的点对点通信方式。广播信道这种信道使用一对多的广播通信方式。广播信道上连接多个主机，必须采用专门的共享信道协议来协调数据发送。数据链路层涉及的问题成帧 (framing)怎么组成帧、怎么使接收方识别帧错差控制帧在传输过程中出错的检测流量控制及可靠传输仅是数据链路层的选项广播信道中的介质访问控制如何使众多用户能够合理且方便地共享通信媒体资源成帧方法主要解决接收方如何识别帧的边界问题。常用的成帧方法有：字符计数法在帧头部字段中指明本帧的字节数，接收方通过该字段得知该接受多少字节。字符填充的首尾定界法定义专门的字符作为帧的起始/结束标志，并使用字符填充方式将标志字符与数据区分开来。比特填充的首尾定界法定义专门的比特序列作为帧的起始/结束标志，并使用比特填充方式将标志序列与数据区分开来。物理编码违例法使用无效的物理编码作为帧的起始/结束标志，供接收方识别。错误检测和纠正任何通信链路在传输数据时都有可能出错，一般用误码率 (Bit Error Rate, BER) 表示链路可靠性：误码率 = 出错的比特数 / 传送的总比特数。当误码率为 $10^{-10}$，表示平均每传送 $10^{10}$ 个比特就会出现一个比特出错。检错编码 (Error detecting code)可检测错误的编码，以重传处理。由于信道的误码率通常都比较低，出错属于小概率事件，因此发现出错的时候只需重传即可，使用检错编码就更有性价比。常用的检错编码方法有：奇偶校验简单累加和（校验和）循环冗余校验 (Cyclic Redundancy Check, CRC)发送方：把数据划分成组，设每组 k 个比特，在其后添加供差错检测用的 n 位冗余码，再将 (k+n) 比特一起发送。接收方：对收到的 (k+n) 比特计算冗余码，结果为 0 表示传输正确，否则表示传输错误。纠错编码 (Error correcting code)可检测错误，并且纠正错误的编码。这类编码看似很好，但实际应用的代价比较高，因为需要为了纠正错误腾出更多冗余比特，成本更高。基本数据链路协议基本数据链路协议有无限制的单工协议、单工停-等协议以及有噪声信道的单工协议。无限制的单工协议其假设前提有： 此协议未考虑接收方的处理速度，像是发送方发送的速度大于接收方的处理速度。 单向传输，即发送方向接收方传输数据，接收方不需要反向的传输数据。 理想信道，即通信是没有错误的。 发送方总有数据发送，并且接收方总能及时处理所收到的数据。单工停-等协议 (stop-and-wait)按照无限制的单工协议，如果接收方的处理速度不及发送方，则可能出现帧丢失的情况。因此就有了解决方法，增加流量控制 (Flow control) 机制，得到单工停-等协议。 虽然这个协议考虑了接收方的处理速度，但其未考虑传输出错的问题。接收方每收到一帧，都向发送方返回一个应答帧。而发送方每发送一帧，都等待来自接收方的应答帧，之后才发送下一帧。有噪声信道的单工协议在有噪声信道中，帧在传输过程中是有可能出错的，此问题的解决方法为 ARQ 协议。ARQ 协议的原理要点有： 校验和，使接收方能够检测帧是否出错 确认帧，使发送方知道帧已被正确接收 超时重发，发送方在规定时间内未收到确认帧，则重发帧 帧序号，保证接收方不会重复接收帧协议设计时，需要考虑的三种情形：数据帧被正确接收接收方返回确认帧，发送方收到后继续发送下一帧。数据帧出错或丢失接收方未收到帧或校验出错丢失该帧，发送方等待确认帧超时后，重新发送数据帧。确认帧出错或丢失发送方未收到有效的确认帧，重发数据帧。接收方收到后，检测到帧序号重复，不上交该帧，仅返回确认帧。滑动窗口协议传输链路存在时延，ARQ 协议在同一时刻仅有一个帧在链路上传输，导致其对信道的利用率较低，特别是传输时延较长的时候。利用率 $U = T_D~/~(T_D~+~RTT~+~T_A)$ $T_D$ ：发送数据帧的时间，$RTT$ ：往返时延 / 环路时延，$T_A$ ：发送应答帧的时间滑动窗口协议原理滑动窗口协议的基本思想是允许发送方连续发送多个帧，并通过滑动窗口实现流量控制。发送方，发送窗内的序列号代表允许它发送的帧。窗口内最大的序列号成为窗口上边界、上沿或前沿。窗口内最小的序列号成为窗口下边界、下沿、后沿。每当从网络层得到一个数据包，将其组成帧发出后，发送窗口的上边界将 +1。发送窗口下边界的帧被接收方确认后，发送窗口的下边界将 +1。接收方，接收窗口内的序列号代表可以接受的帧。收到的帧序列号等于窗口下边界时，将该帧上交网络层，并返回确认帧，同时整个窗口向前移动 1 个位置。如果收到帧序列号落在接收窗口之外，则将其丢弃。后退N帧的滑动窗口协议当某帧出错时，该帧之后的帧全部被丢弃，从出错帧开始重新发送。选择性重传的滑动窗口协议当某帧出错时，只选择性重发该帧，该帧之后发送的帧会先由接收方在数据链路层缓冲，收到重发的出错帧之后再上交给网络层。 ACKn 表示 n 及 n 之前的帧均已被正确接收当接收方检测到出错帧时，会发送一个否定的确认帧 (Negative Acknowledgement, NAK)。这样的好处是，发送方可以尽快重发出错帧，不必等到超时。点对点协议 PPPPPP 全称为 Point-to-Point Protocol，是一种数据链路层协议，广泛应用于点到点链路的数据传输。PPP 协议的特点PPP 协议有三个组成部分，分别是： 将 IP 数据封装到串行链路的方法 用来建立、配置和测试数据链路连接的链路控制协议 Link Control Protocol LCP 一套网络控制协议 Network Control Protocol NCPPPP 的帧格式零比特填充属于同步传输，如 SONET / SDH。发送端：只要发现有 5 个连续 1，则立即填入一个 0。接收端：对帧中的比特流进行扫描，每当发现 5 个连续 1 时，就把这 5 个连续 1 后的一个 0 删除。字符填充属于异步传输。发送端：信息字段（载荷）中的每一个 0x7E 转换成 0x7D, 0x5E。信息字段中的每一个 0x7D 转换成 0x7D, 0x5D。信息字段中的每一个 ASCII 码控制字符（小于 0x20 的字符）前面都加入 0x7D，且编码改变。如 0x03 转换成 0x7D, 0x23。接收端：在收到数据后进行与发送端字节填充相反的变换，即可正确恢复原来的信息。PPP 协议的工作状态鉴别状态中，若鉴别成功，则进入网络层协议 (Network-Layer Protocol)。否则进入链路终止状态 (Link Terminate)。PPP支持两种身份认证协议，即：口令鉴别协议 PAP (Password Authentication Protocol)若使用 PAP，则需要发起通信的一方发送身份标识符和口令。口令握手界别协议 CHAP (Challenge-Handshake Authentication Protocol)若需要更好的安全性，则使用更加复杂的 CHAP。介质访问控制 (Media Access Control, MAC)广播信道可以进行一对多的通信，而局域网使用的就是广播信道。局域网是在 20 世纪 70 年代末发展起来的。局域网技术在计算机网络中占有非常重要的地位。局域网的数据链路层局域网最主要的特点是，网络为一个单位所拥有，且地理范围和站点数目均有限。其优点有： 具有广播功能，从一个站点可以很方便的访问全网。局域网上的主机可共享连接在局域网上的各种硬件和软件资源。 便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变。 提高了系统的可靠性、可用性和生存性。局域网可按拓扑进行分类，其中有星形网、环形网及总线网。由于局域网通常使用广播信道，可能会有多个主机同时访问信道。共享信道要着重考虑的问题是如何使众多用户能够合理且方便地共享通信媒体资源，因此就有了介质访问控制技术。其中有两种方法：静态划分信道有如频分复用、时分复用、波分复用以及码分复用。用户只要分配到了信道，就不会与其他用户发生冲突。但这种划分信道的方法代价较高，不适用于局域网。动态介质访问控制 / 多点访问其特点是信道并非在用户通信时固定分配给用户，分为以下两类：随机访问所有用户可随机发送信息。但如果有两个或更多的用户在同一时间发送信息，就会产生碰撞。因此，必须有解决碰撞的网络协议。经典的协议有：CSMA/CD、CSMA/CA等。受控访问用户不能随机发送信息，而必须服从一定的控制，局域网中使用较少。经典代表有：分散控制的令牌环局域网和集中控制的多点线路探询，或轮询。CSMA/CD 协议全称为载波监听多点访问/碰撞检测 Carrier Sense Multiple Access with Collision Detection，是一种随机访问协议，也是以太网的核心，非常重要。其优点： 网络负载较低时，效率高。 硬软件实现简单、灵活。其缺点： 网络负载较重时，碰撞发生的概率增大，网络效率较低。 由于存在多次冲突的可能，数据从发送方到接收方的时间没有保证，即实时性较差。载波监听发送前先听：结点在发送数据之前会先检测一下，总线上是否有其他结点正在发送数据。若有则暂时不发送数据，以免发生碰撞。碰撞检测由于线路的传播时延，单纯靠载波监听并不能完全避免碰撞。有发生碰撞时，两个或更多的信号在总线上相互叠加，会导致无法识别。边发送边听：结点边发送数据边检测信道上是否发生了碰撞。碰撞强化发送方检测到碰撞后，立刻停止发送，并发送 32 或 48bit 的人为干扰信号 (jamming signal)，以便让所有用户都知道已经发生了碰撞。碰撞退避碰撞后，结点将等待一段时间，再重新开始载波检测和发送操作。为了避免退避后再次碰撞，冲突各方的等待时间就应该各不相同。因此，以太网采用了截断二进制指数退避算法 (truncated binary exponential backoff)。截断二进制指数退避算法的特点有： 退避时间：$T=2\\tau \\times $倍数 倍数：在 $0,1,\\dots,2^k - 1$ 中取随机数，其中 k = min(重传次数, 10)。 重传次数超过 16 后，则丢弃该帧，并向上层报告。争用期一个站点开始发送数据后，最多经过时间 $2\\tau$，就可以知道是否发生了碰撞。如果经过争用期还没检测到碰撞，就可以肯定这次发送不会发生碰撞。以太网争用期以太网的端到端往返时延 $2\\tau$ 称为争用期，或碰撞窗口。其争用期长度为 $51.2~\\mu s$。对于 10Mb/s 以太网，在争用期内可发送 512 bit，即 64 字节。因此在发送数据时，若前 64 字节未发生碰撞，就不会发生碰撞。根据此规定，以太网帧长 $\\ge$ 64 字节，长度小于 64 字节的帧为无效帧。局域网技术标准IEEE802 标准将局域网的数据链路层分为两个子层，分别是：逻辑链路控制子层 (Logic Link Control, LLC)逻辑链路控制子层，是局域网中数据链路层的上层部分，用户的数据链路服务透过 LLC 子层为网络层提供统一的接口。在 LLC 子层下面是 MAC 子层。介质访问控制子层 (Media Access Control, MAC)介质访问控制子层，是局域网中数据链路层的下层部分，提供定址及媒体存取的控制方式，使得不同设备或网络上的结点可以在多点的网络上通讯，而不会互相冲突。以太网IEEE802 委员会的 802.3 工作组于 1983 年制定了第一个 IEEE 的以太网标准 IEEE802.3，数据率为 10Mb/s。DIX Ethernet V2 与 IEEE802.3 标准只有很小的差别，因此有很多人常把 802.3 局域网简称为以太网。但严格来说，以太网应该是指符合 DIX Ethernet V2 标准的局域网。曼彻斯特 (Manchester) 编号二进制基带数字信号通常是高、低电压交替出现的信号。当信号出现一长串连续的 0 或 1 时，接收端就无法从收到的比特流中取位同步信号。曼彻斯特编码的编码方法就是把每一个码元分成两个相等的间隔，码元 1 是前一个间隔为低电压而后一个间隔为高电压。码元 0 则正好相反，从高电压转为低电压。这样保证每个比特的正中间都出现一次电压转换，接收端就可以利用这种电压的转换把位同步信号提取出来。以太网物理层最初的以太网为总线结构，采用 $50\\Omega$ 同轴电缆，传输速率为 10Mbps。其缺点是： 同轴电缆成本较高 总线上单点故障会导致全网瘫痪。网络中结点数较多时，可靠性较差，且维护困难。后来发展为采用更便宜和灵活的非屏蔽双绞线，使用集线器 (HUB) 连接各个结点，物理上呈星形结构。集线器就很像一个多接口的转发器，工作在物理层。使用集线器的以太网在逻辑上仍然是一个总线网。这种技术称为 10BASE-T。 10：10Mbps，BASE：基带传输，T：双绞线 (Twisted pair)以太网的 MAC 层以太网采用 CSMA/CD 介质访问控制协议。所有的结点都会被分配一个按照 IEEE802.3 标准，且唯一的 MAC 地址。该地址为 48bit，高 24bit 为厂商标识符，低 24bit 由厂商自行分配，且必须保证每个网络接口具有全球唯一的 MAC 地址。当一个结点发送数据时，由于以太网的总线结构，总线上的所有结点都能收到帧。因此就需要一个适配器 (Adapter) 在每收到一个帧的时，就检查帧中的目的 MAC 地址。如果是发往本站的帧则进行处理，否则丢弃。发往本站的帧包括以下三种帧：单播帧 / 一对一 (Unicast)广播帧 / 一对全体 (Broadcast) — MAC 地址为全 1 就表示广播组播 / 多播 / 一对多 (Multicast)以太网的帧格式（5个字段）每个帧在发送时，前面都会插入 8 个字节。其中前 7 个字节用于比特同步，后 1 字节为帧起始标志。由于以太网采用曼彻斯特编码，每个比特均有电平跳变，因此无电平跳变就表示总线空闲。目的地址6 字节，接收方的 MAC 地址。源地址6 字节，发送方的 MAC 地址。类型2 字节，标明上层协议类型，例如 0x0800 表示 IP 包。数据网络层数据报，长度为 46 ~ 1500 字节。最小为 46 字节是由以太网有效帧的最小长度 64 字节，扣除目的地址、源地址、类型及 FCS 计算出来的，即 64 - 6 - 6 - 2 - 4 = 46 字节。帧校验序列 (Frame Checksum, FCS)4 字节，帧校验序列，采用 CRC 校验。快速以太网 (Faster Ethernet)其标准为 IEEE802.3u，传输速率为 100Mb/s，其使用 8 芯非屏蔽双绞线中的 4 条芯，其中 2 条用以发送，2 条用以接收。这使其可在全双工方式下工作而无冲突发生，因此 CSMA/CD 协议对全双工方式工作的快速以太网就不起作用了。其使用的 MAC 帧格式仍然是 IEEE802.3 标准规定的帧格式，最短的帧长也保持不变。由于传输速率有所提升，争用期有所缩短，导致一个网段的最大电缆长度减小至 100m。快速以太网的物理层标准有：100BASE-TX使用媒体为铜缆，网段的最大电缆长度为 100m，特点是使用 2 对 UTP 5 类线或屏蔽双绞线 STP。100BASE-T4使用媒体为铜缆，网段的最大电缆长度为 100m，特点是使用 4 对 UTP 3 类线或 5 类线。100BASE-FX使用媒体为光缆，网段的最大电缆长度为 2000m，特点是两根光纤，发送与接收个一根。千兆以太网 / 吉比特以太网 (Gigabit Ethernet)其标准为 IEEE802.3z，传输速率为 1Gb/s，其迅速占领市场，成为以太网的主流产品。吉比特以太网的标准 IEEE802.3z 有以下几个特点： 允许在 1Gb/s 下以全双工和半双工两种方式工作。 仍使用 IEEE802.3 协议规定的帧格式。 在半双工方式下使用 CSMA/CD 协议，全双工方式则不使用。 支持自适应，与 10BASE-T 和 100BASE-T 技术向后兼容。吉比特以太网的物理层标准有：1000BASE-SX使用媒体为光缆，网段的最大电缆长度为 550m，特点是采用多摸光纤。1000BASE-LX使用媒体为光缆，网段的最大电缆长度为 5000m，特点是采用单模光纤及多摸光纤。1000BASE-CX使用媒体为铜缆，网段的最大电缆长度为 25m，特点是使用 2 对屏蔽双绞线电缆 STP。1000BASE-T使用媒体为铜缆，网段的最大电缆长度为 100m，特点是使用 4 对 UTP 5 类线。万兆以太网 / 10 吉比特以太网 (10Gbps Ethernet)其标准为 IEEE802.3ae，传输速率为 10Gb/s，只使用光纤传输。其使用的 MAC 帧格式仍然是 IEEE802.3 标准规定的帧格式，并保留了 802.3 标准规定的以太网最小帧长与最大帧长。由于万兆以太网仅工作在全双工方式，不存在争用问题，也就不使用 CSMA/CD 协议。因此其传输距离大大提高，不再受限于争用期。局域网互连在物理层扩展局域网使用中继器 (repeater) 或集线器 (HUB)，可实现局域网在物理层的互连。中继器和集线器都工作在网络的物理层。其优点是，可以方便地实现网络的扩展，并且成本较低。而缺点则是，碰撞域增大，碰撞发生概率增大，可能会影响网络性能。在数据链路层扩展局域网使用网桥 (bridge) ，可实现局域网在数据链路层的互连。网桥工作在网路的数据链路层。网桥的基本工作原理是根据 MAC 帧的目的地址对收到的帧进行转发，即其具有过滤帧的功能。当收到一个帧时，会先检查帧的目的 MAC 地址，确定将该帧转发到哪一个接口，而非向所有的接口转发。转发表是由交换机根据自学习算法建立的。其优点是，可过滤通信量、增大吞吐量，因为各网段都是独立的碰撞域。同时，其扩大了物理范围，可互连不同物理层、不同 MAC 子层和不同速率的局域网，提高了可靠性。其缺点是，其存储转发的方式增加了时延，并且在 MAC 子层并没有流量控制功能。因此网桥只适用于用户数不太多和通信量不太大的局域网，因为若某个站点频繁发送广播帧（MAC 地址全为 1 的帧）时，就会产生网络拥塞，即广播风暴。多接口网桥 — 交换机 Switch早期称为交换式集线器 (switching hub)，通常有十几道几十个网络接口，每个接口可连接主机或其他交换机。其内部工作原理为网桥，每一个网络接口被视为一个网段，因此交换机是一个多接口网桥。其按照自学习算法建立转发表，原理是若从 A 出发的帧从接口 x 进入到某网桥，则从这个接口出发沿相反方向一定可以把一个帧传送到 A。由于每一个网络接口被视为一个网段，并且每个接口都独享宽带，因此可以大幅提高网络性能。集线器则由所有接口共享传输介质的带宽。交换机的自学习过程交换机初始时转发表为空，通过自学习逐步建立。交换机在收到一个帧后，会先进行自学习，检查帧中源地址在交换表中是否存在。若不存在，则在交换表中添加一项，记录源地址和进入交换机的接口。然后转发帧，根据收到的帧中的目的地址在交换表中查找。若找到，则对应的接口为转发接口。若找不到，则向除进入接口外的所有接口转发，再根据目的地址返回的应答帧进行相应记录。透明网桥还使用生成树算法 (spanning tree)其用途是，当多个局域网互连形成环路时，避免帧无休止转发。所使用的方法为建立生成树，即互连在一起的网桥彼此通信后，能找出网络拓扑的一个子集。在该子集中，整个连通的网络不存在回路，即在任何两个站之间只有一条路径。但考虑到网络拓扑的动态变化，生成树必须定期更新。虚拟局域网 Virtual LAN虚拟局域网，是在现有局域网的基础上，通过将网络站点分组，构成若干个逻辑上独立的虚拟局域网。其用途是，便于管理、控制广播风暴以及安全性等。帧不会在两个虚拟局域网之间自动转发，包括广播帧。这样，虚拟局域网限制了接收广播信息的计算机数，使得网络不会因为传播过多的广播信息而引起性能恶化。IEEE 批准了 802.3ac 标准，定义了以太网的帧格式的扩展，以便支持虚拟局域网。虚拟局域网允许在以太网的帧格式中插入一个 4 字节的标识符，称为 VLAN 标记 (tag)，用来指明发送该帧的计算机术语哪一个虚拟局域网。而插入 VLAN 标记得出的帧，就称为 802.1Q 帧。" }, { "title": "物理层 Physical Layer", "url": "/posts/%E7%89%A9%E7%90%86%E5%B1%82-Physical-Layer/", "categories": "Notes, Computer Network", "tags": "Computer Network", "date": "2022-03-05 13:01:00 +0800", "snippet": "物理层的基本概念物理层主要任务为确定与传输媒体的接口有关的一些特性，像是：机械特性 — 接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置等电气特性 — 接口电缆的各条线上出现的电压的范围功能特性 — 某条线上出现的某一电平的电压的意义过程特性 — 对于不同功能的各种可能事件的出现顺序数据通信的基础知识信道 (Channel) 一般表示向某一方向传送信息的介质。通信的目的是传送 消息 (Message)，消息的实体是 数据 (Data)。信号 (Signal) 是数据的电气的或电磁的表现，分为模拟信号和数字信号两大类。在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形称为 码元。码元速率 指单位时间内通过信道的码元个数，单位为 波特 (baud)。数据速率 指单位时间内通过信道的信息量，单位为 b/s 或 bps。有关信号的几个基本概念通信的双方信息交互的方式有三种基本方式。单项通信 或 单工通信 (Simplex)只能有一个方向的通信，没有反方向的交互。双向交替通信 或 半双工通信 (Half-duplex)通信的双方都可以发送信息，但不能同时发送和接收信息。双向同时通信 或 全双工通信 (Duplex)通信的双方都可以同时发送和接收信息。基带信号 或 基本频带信号 (baseband)来自信源的信号。计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。带通信号 (band pass)基带信号经过载波调制后，信号的频率范围搬移到较高的频段以便在信道中传输。调制 (modulation)基带信号包含很多低频成分，甚至有直流成分，许多信道并不能传输这种低频分量或直流分量。为解决这一问题，就必须对基带信号进行调制。基本的二元制调制方法调幅 (Amplitude Modulation, AM)载波的振幅随着基带数字信号而变化，如 0 或 1 分别对应无载波或有载波输出。调频 (Frequency Modulation, FM)载波的频率随着基带数字信号而变化，如 0 或 1 分别对应频率 $f_1$ 或 $f_2$。调相 (Phase Modulation, PM)载波的初始相位随着基带数字信号而变化，如 0 或 1 分别对应相位 0 度或 180 度。信道的极限容量信号失真问题任何实际的信道都不是理想的，在传输信号时会产生各种失真以及带来多种干扰，不可能以任意高的速率进行传送。码元传输的速率越高，或信号传输的距离越远，在信道的输出端的波形的失真就越严重。信道能够通过的频率范围一个信道所能通过的频率范围总是有限的，高频分量往往不能通过信道。如果信号中的高频分量在传输时受到衰减，在接收端收到的信号波形失去了码元之间的清晰界限，这种现象就叫码间串扰。奈奎斯特定理 (Nyquist)理想低通信道最大数据传输率：$2H~log_2 V$ (bps) H：信道带宽，V：信号电平的级数在任何信道中，码元传输的速率都是有上限的，传输速率超过此上限，就会出现严重的码间串扰的问题，使接收端对码元的判决（即识别）成为不可能。如果信道的频带越宽，能通过的信号高频分量越多，就可以用更高的速率传送码元而不出现码间串扰。信噪比噪声存在于所有的电子设备和通信信道中。噪声会使接收端对码元的判决产生错误，但其影响也是绝对的。若信号相对较强，噪声的影响就相对较小。信噪比就是信号的平均功率和噪声的平均功率之比，常记为 $S/N$，度量单位为分贝 dB。信噪比 (dB) $=~10~log_{10}(S/N)$ (dB)香农公式信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高。信道的极限信息传输速率 $C = W~log_2(1+S/N)$ (bit/s) W：信道带宽(Hz)，S：信道内所传信号的平均功率，N：信道内部的高斯噪声功率物理层下面的传输介质传输介质，又称为传输媒体或传输媒介，指数据传输系统中发送器和接收器之间的物理通路。传输媒体分为两大类，导引型传输介质及非导引型传输介质。导引型传输介质在导引型传输媒体中，电磁波被导引沿着固体媒体（铜线或光纤）传播。双绞线 (twisted pair)将两根互相绝缘的铜导线并排放在一起，用规则的方法绞合起来就构成了双绞线。绞合可减少对相邻导线的电磁干扰。在网络时代前，使用双绞线最多的地方就是到处都有的电话系统。其价格便宜，便于安装使用，但传输距离较短。双绞线可分为非屏蔽双绞线以及屏蔽双绞线，屏蔽双绞线是在双绞线的外面加上一层用金属丝编织成的屏蔽层，以提高双绞线抗电磁干扰的能力。局域网布线系统常使用8芯非屏蔽双绞线。同轴电缆 (coaxial cable)由内导体铜质芯线、绝缘层、网状编织的外导体屏蔽层以及保护塑料外层组成。其抗干扰能力和传输速率均高于双绞线，但造价较高，大规模安装使用不便。广泛应用的同轴电缆分为 $50\\Omega$ 同轴电缆和 $75\\Omega$ 同轴电缆。光纤 (fiber optics)光纤由非常透明的石英玻璃拉成细丝，由纤芯和包层构成双层通信圆柱体。光纤分为多摸光纤以及单模光纤。光纤通信的优点如下： 通信容量大 传输损耗小，通信距离长 抗干扰能力强、保密性好 体积小、重量轻但安装较为复杂，需要专用设备、光电转换等。广泛应用于长途干线传输、局域网或城域网的干线、高带宽且高可靠的网络连接，像是服务器等。多摸 (multi-mode) 光纤从纤芯中射到纤芯表面的光线的入射角大于某个临界角度，就会产生反射。因此，可存在多条不同角度入射的光线在一条光纤中传输。光脉冲在多摸光纤中传输会逐渐展宽，造成失真，因此只适合于近距离传输。单模 (single-mode) 光纤光纤的直径减小到只有一个光的波长，则光纤可像一根波导一样，使光纤一直向前传播不反射。单模光纤的衰耗较小，可在高速率下进行较长距离的传输。非导引型传输介质非导引型传输媒体就是自由空间，在非导引型传输媒体中，电磁波的传输常称为无线传输。其主要分类为短波通信和微波通信及卫星通信。无线通信的适用场合有偏远地区、城市中敷设线缆较为困难的场合以及移动设备。短波通信通过电离层反射，传输距离长，通信质量较差，传输速率低。微波通信及卫星通信微波的频率范围为 300Mhz ~ 300Ghz，但主要使用 2 ~ 40Ghz 的频率范围。微波在空间主要是直线传播，可使用抛物面状天线将能量聚集成束，从而获得极高信噪比。地面微波接力通信由于微波在空间是直线传播的，为了实现远距离通信就必须在一条微波通信信道的两个终端之间建立若干个中继站，中继站将前一站送来的信号放大之后再发送到下一站，因此称为接力。其优点： 微波波段频率高，通信频段范围宽，因此通信信道的容量大。 无线通信中，抗干扰能力较强，传输质量较高。 建设速度快、成本低。其缺点： 相邻站之间必须直视，不能有障碍物，容易受地理或建筑物影响。 有时会受气候影响，像是雷电、太阳黑子爆发等。 与电缆通信系统比较，隐蔽性和保密性较差。 中继站的使用和维护需要消耗较多人力和物力。卫星通信主要通过卫星进行微波信号转发。其特点是具有较大的传播时延，对于地球同步卫星单向时延可达 250-300ms，一般可取为 270ms。地球同步卫星的优点如下： 通信距离远、覆盖范围广。 频带宽，通信容量较大。 信号受到的干扰较小，通信比较稳定。除了地球同步卫星之外，低轨道卫星在数据通信领域发展较快，主要是因为其以下特点： 卫星造价和发射成本低。 传输距离短，信号衰减小，可与地面手持设备通信。 传播时延较小。关于无线频谱政策多数的无线频段由政府管理和分配。若想使用某一段无线电频谱进行通信，则必须得到本国政府有关无线电频谱管理机构的许可证。这是因为电磁波在空间中传播时会相互影响，且无线频段范围有限。但也存在一些无线电频段是可以自由使用的，即 ISM 频段，ISM 是 Industrial, Scientific, Medical 的缩写。使用 ISM 频段的限制为发射功率必须小于 1 Watt，使用的设备有 WLAN、蓝牙、无线鼠标等，这极大地促进了短距离无线通信的应用。信道复用技术复用 (Multiplexing) 是在一个信道上传输多路信号。频分多路复用 (Frequency Division Multiplexing, FDM)频分多路复用是每个用户占用不同的频带资源，用户在通信的过程中自始至终都占用这个频带。时分多路复用 (Time Division Multiplexing, TDM)时分多路复用是将时间划分成一段段等长的时隙，每个用户在不同的时隙 (time slot) 占用同样的频带宽度，便于数字传输。统计时分多路复用 (Statistic TDM)一种根据用户实际需求动态分配线路资源的时分复用法。只有当用户有数据要传输时才给他分配线路资源，可提高线路的利用率。波分复用 (Wavelength Division Multiplexing, WDM)波分复用是光的频分复用，是使用光调制器将一系列载有信息，但波长不同的光信号合成一束，沿着单根光纤传输。接收端再用光解调器将各个不同波长的光信号分开。这使光线的传输能力大幅提升。密集波分复用 (Dense WDM)波分复用的一种具体表现形式。其波长间隔很小，因此可将几十路甚至一百多路的光载波信号复用到一根光纤中传输。由于 DWDM 的普及应用，目前人们讨论的 WDM 系统几乎全都是 DWDM。码分复用 (Code Division Multiplexing, CDM)更常用的名次为码分多址 (Code Division Multiplexing Access, CDMA)。每个用户可在同一时间使用同一频带进行通信。由于各用户使用经过特殊挑选的不同码型，各用户之间不会造成干扰，因此这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声。数字传输系统数字通信与模拟通信相比，传输质量上或经济上都有明显优势。目前，长途干线大都采用时分复用 PCM 的数字传输方式。早期的数字传输系统存在着许多缺点，其中主要的是以下两个：速率标准不统一由于历史的原因，多路复用的速率体系有两个互不兼容的国际标准，再往上的复用又有第三种不兼容的标准。这导致国际范围的基于光纤的高速数据传输就很难实现。不是同步传输为节约经费，各国的数字网主要采用准同步方式。在准同步系统中各支路信号的时钟频率有一定偏差，给时分复用和分用带来许多麻烦。当数据传输速率很高时，收发双方的时钟同步就成为很大的问题。脉码调制系统 (Pulse Code Modulation, PCM)用于电话交换系统，在数字传输系统中进行多路语音的变化与传输。脉冲编码调制是一种对模拟信号数字话的采样技术，将模拟语音信号变换为数字信号的编码方式，特别是对于音频信号。PCM 对信号每秒钟采样 8000 次。每次采样数据为 8bit，语音数据速率为 64kb/s。数据化的语音数据进行时分多路复用。同步光纤 (Synchronous Optical Network, SONET)用于高速干线传输，特别是光纤传输。美国在 1988 年首先推出的一个数字传输标准，整个的同步网络的各级时钟都来自一个非常准确的主时钟。SONET 光纤传输系统定义了同步传输的线路速率等级结构，其传输速率以 51.84Mbit/s 为基础。同步数字系列 (Synchronous Digital Hierarchy, SDH)ITU-T 以美国标准 SONET 为标准制定出的国际标准。最基本的模块为 STM-1，传输速率为 115.52Mbit/s。第 1 级同步传递模块 (Synchronous Transfer Module-1, STM-1)通过光纤传输数据的一系列标准。SDH 标准规定 STM-1 的传输速率为 115.52Mbit/s，并把 n 倍的速率记为 STM-n。宽带接入技术通常指远程用户访问网络的技术，目前宽带尚无统一的定义，宽带接入泛指超越传统的 modem + 电话线拨号上网（最高 56kbps）的技术。2015 年 1 月，美国联邦通信委员会 FCC 对接入网的宽带进行了重新定义，将原定的带宽下行速率调整至 25MBit/s，原定的宽带上行速率调整至 3MBit/s。从宽带接入的媒体来看，可划分为两大类。一类是有线宽带接入，而另一类是无线宽带接入。xDSL技术 (Digital Subscribe Line)最后一英里 (last mile)通常指通信运营商局端到家庭用户之间的本地回路，是宽带接入技术需要面对的核心问题之一。由于对此段线路进行数字化改造代价高昂，因此仍普遍采用模拟传输方式。xDSL技术在不改变最后一英里 (last mile) 线路的前提下，通过改造现有的模拟电话用户线的传输方式，使其能够承载宽带业务。xDSL的几种类型有：Asymmetric Digital Subscriber Line, ADSLHigh speed DSL, HDSLSingle-line DSL, SDSLVery high speed DSL, VDSLHFC光纤混合同轴网 (Hybrid Fiber Coax)一种结合光纤与同轴电缆的宽掉接入网，由光纤取代一般电缆线，是一个以有线电视网 CATV 为基础的宽带接入技术。HFC 有单线网和双向网两种，单向 HFC 网仅用光纤取代了传统 CATV 网主干线电缆，扩大了接入网的覆盖范围，基本上仅支持 CATV 业务。而双向 HFC 则是在单向 HFC 网络基础上改造而成，可提供 CATV、语音、数据和其他交互型业务。HFC 的主要特点有： 主干线路采用光纤，并采用结点体系结构。光纤从头端连接到光纤结点。在光纤结点光信号被转换为电信号，再通过同轴电缆传送到每个用户家庭。 具有比 CATV 网更宽的频谱，且具有双向传输功能。其宽带可满足综合业务和高速数据传输需要。 每个家庭都需要安装一个用户接口盒 (User Interface Box, UIB)。用户接口盒提供 3 种连接，分别是同轴电缆连接到机顶盒 (set-top box)、双绞线连接到用户的电话机、电缆调制解调器 (cable modem) 连接到用户的计算机。基于光纤的宽带接入 FTTx这是基于光纤传输的宽带接入技术。现有许多不同的 FTTx，像是光纤到户 (Fiber To The Home, FTTH)、光纤到大楼 (Fiber To The Building, FTTB)、光纤到路边 (Fiber To The Curb, FTTC) 等。目前用于光纤到户的技术为无源光网络 (Passive Optical Network, PON)。无源表示在光配线网中无需配备电源，因此运营维护成本低。光配线网采用波分复用，上行和下行分别使用不同的波长。无源光网络的种类很多，但最流行的是以太网无源光网络 (Ethernet PON) 及吉比特无源光网络 (Gigabit PON)。以太网无源光网络 (Ethernet PON)2004 年 6 月形成了 IEEE 的标准 802.3ah。在链路层使用以太网协议，利用 PON 的拓扑结构实现了以太网的接入。其优点有，与现有以太网兼容性好、成本低、扩展性强、管理方便。吉比特无源光网络 (Gigabit-capble PON)2003 年 1 月 ITU 批准的 ITU-T G.984 标准。GPON 采用通用封装方法 (Generic Encapsulation Method, GEM)，可承载多业务，对各种业务类型都能提供服务质量保证，是很有潜力的宽带光纤接入技术。" }, { "title": "计算机网络概述", "url": "/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/", "categories": "Notes, Computer Network", "tags": "Computer Network", "date": "2022-03-02 14:51:00 +0800", "snippet": "计算机网络的定义计算机网络是一些互相连接的、自治（一个计算机网络连接多台计算机，但各自独立工作）的计算机的集合。其功能主要体现在连通性、资源共享。计算机网络与分布式系统分布式系统是建立在网络之上的软件系统。在分布式系统中，一组独立的计算机协同完成一个工作，展现给用户的是一个统一的整体，就像一个系统一样。而计算机网络则没有这种统一性。计算机网络的分类计算机网络的分类有：按作用范围（或覆盖范围）分类广域网（Wide Area Network）通常跨接很大的物理范围，所覆盖的范围从几十公里到几千公里，它能连接多个地区、城市和国家，或横跨几个洲并能提供远距离通信，形成国际性的远程网络。局域网（Local Area Network）由两个以上相连的计算机组成，LAN是包含在较小地理区域内的网络，其覆盖的范围通常位于同一建筑物或同一单位内。城域网（Metropolitan Area Network）其覆盖的范围通常是一个城市，属于宽带局域网，常采用局域网技术建立。由于采用具有有源交换元件的局域网技术，网中传输时延较小，它的传输媒介主要采用光缆，传输速率在100兆比特/秒以上。个人区域网（Personal Area Network）指个人范围的计算设备组成的通信网络，可实现各种计算设备互连、互相交换数据的网络。通常采用无线技术，像是蓝牙或红外，因此又称为Wireless Personal Area Network，简称WPAN。其覆盖的范围较短，大约在10m左右。按网络使用者进行分类公用网（Public Network）指所有愿意按邮电部门规定交纳费用的人都可以使用的网络，也指网络服务提供商建设，供公共用户使用的通信网络。公用网一般由国家的邮电部门建造。专用网（Private Network）专用网指专用于一些的保密性要求较高的部门的网络，比如企业内部专用网、军队专用网，尤其是涉及国家机密的部门。计算机网络的性能计算机网络的性能指标可以从不同的方面来度量计算机网络的性能。性能指标速率传输数据的速率，即数据速率（data rate）或比特率（bitrate），单位为b/s（bit per second）带宽（Bandwidth）原本指某个信号具有的频带宽度；通信线路允许通过的信号频带范围称为线路带宽。而计算机网络中，则指通信线路传输数据的能力，即最高数据率。吞吐量单位时间内通过网络的数据量，常用作实际网络的测量指标。时延（Delay, Latency）指数据从网络一端传送到另一端所需的时间，也称为延迟。网络时延由多个部分组成，其中有发送时延、传播时延、处理时延及排队时延。时延带宽积时延带宽积 = 传播时延 x 带宽，又称为以比特为单位的链路长度。往返时间（Round-Trip Time）指从发送方发送数据开始，到发送方收到来自接收方的应答所经历的时间，因此又称为环路时延、回路时延。利用率这里包括信道利用率和网络利用率。信道利用率指某信道有百分之几的时间是被利用的，即有数据通过的。而网络利用率则是全网络的信道利用率的加权平均值。非性能指标费用 质量 标准化 可靠性 可扩展性和可升级性 易于管理和维护计算机网络的体系结构计算机网络的体系结构是计算机网络的各层及其协议的集合。由于实现信息在网络中传输非常复杂，因此使用了分层的方法有效的将复杂的问题简单化、局部化。具有七层和五层协议的体系结构OSI体系结构物理层、数据链路层、网络层、传输层、会话层、表示层、应用层TCP/IP体系结构网络接口层（物理层—网络层）、网际层（网络层）、传输层、应用层（会话层—应用层）五层体系结构物理层、数据链路层、网络层、传输层、应用层（会话层—应用层）实体、协议、服务和服务访问点实体（Entity）任何可发送或接收信息的硬件或软件进程。协议（Protocol）控制两个对等实体进行通信的规则的集合。协议对上层的服务用户是透明的，服务用户只能看到下层提供的服务。服务（Service）在协议的控制下，两个对等实体间的通信使得该层可以向上一层提供服务；要实现该层协议，还需要使用下层所提供的服务。服务访问点（Service Access Point）同一系统相邻两层的实体进行交互的地方。计算机网络标准化标准化对于计算机网络至关重要。若要实现不同厂商的软、硬件之间的互连，大家就必须遵从统一的标准。标准的分类标准可分为法定标准以及事实标准。法定标准由权威机构制定的正式、合法的标准。事实标准某些公司的产品在竞争中长时间占据主流，产品中的协议和技术就成了标准。标准化组织ITU-T (International Telecommunication Union)国际电信联盟电信委员会。各国按条约建立的机构，主要成员是各国的邮电部，主要负责制定电信行业的标准。ISO (International Standard Organization)国际标准化组织。业务性组织，主要成员是各大公司技术人员、大学教授、政府官员。主要负责各行业的标准制定，主要贡献有ISO/OSI RM。IEEE (The Institute of Electrical and Electronics Engineers)电子、电气学工程师学会。专业性组织，主要成员是学术团体，主要贡献有IEEE 802系列局域网标准。IETF (Internet Engineering Task Force)Internet工程任务组。主要负责Internet相关标准的制定，标准形式为RFC xxxx（Request for Comment）。" }, { "title": "权重绘制 Weight Paint", "url": "/posts/%E6%9D%83%E9%87%8D%E7%BB%98%E5%88%B6-Weight-Paint/", "categories": "Notes, Blender", "tags": "Blender", "date": "2022-02-06 18:23:00 +0800", "snippet": "权重绘制（Weight Paint），是在物体表面上绘制权重，权重图中的颜色由蓝到红分别表示着0到1之间的值。这里使用绘制权重的原因是为了让甜甜圈表面上的彩色糖只出现在我们想让它出现的位置，而不是到处都是彩色糖。在进入权重绘制（Weight Paint）模式后，可以根据需求对权重（Weight）、半径（Radius）以及强度（Strength）的调整，在物体表面进行权重绘制。以上是我所绘制的权重图，以供参考。绘制完权重后，若想要在实现以上说的让甜甜圈表面上的彩色糖只出现在我们想让它出现的位置，则需要将绘制好的权重图输入到彩色糖的分布上。因此我们需要在几何节点（Geometry Nodes）中的组输入（Group Input）节点中加入一个输入群组以输入我们的权重图。在节点界面中按下n键可以显示节点的各个信息，在节点群组中加入一个输入群组，并将其类型（Type）设定浮点（Float），这是因为我们的权重图是由0到1的浮点数组成的。加入此输入群组后，可以到Blender界面右边的属性栏（Properties）中的修改器属性（Modifier Properties）里，为刚加入的输入群组设定为我们的权重图。随后将其连接到分布点于面上（Distributed Points on Faces）节点的密度系数(Density Factor）中，这样此节点就会根据我们所绘制的权重图，在物体的表面上生成对应的点。以上是绘制权重图之前甜甜圈的渲染图。以上是绘制权重图，并输入到节点之后甜甜圈的渲染图，可见甜甜圈表面上的彩色糖是根据先前绘制好的权重图分布的。以上是完成输入权重图后的实际操作界面，可供参考。" }, { "title": "几何节点 Geometry Nodes", "url": "/posts/%E5%87%A0%E4%BD%95%E8%8A%82%E7%82%B9-Geometry-Nodes/", "categories": "Notes, Blender", "tags": "Blender", "date": "2022-01-27 17:41:00 +0800", "snippet": "和阴影模式（Shading）一样，几何节点（Geometry Nodes）里的节点（Nodes）的执行顺序也是由左到右的。节点 Node这里仅记录我学习过程中有使用到的节点，会随着自己学习使用到的慢慢添加。分布点与面上（Distributed Points on Faces）— 此节点可在一个面上生成多个点，供其他节点使用。这里使用此节点生成多个点，供之后放置彩色糖的节点使用。欧拉旋转（Rotate Euler）— 此节点可实现物体的旋转。这里使用此节点配合随机值（Random Value）节点，随机旋转节点的角度，让每个彩色糖都有不同的放置角度。实例化于点上（Instance on Points）— 此节点可将输入所提供的物体放置到点上。这里将弄好的Cylinder物体输入到此节点的实例（Instance）上，让节点将Cylinder物体作为彩色糖实例化于分布点与面上（Distributed Points on Faces）节点生成的点上。合并几何（Join Geometry） — 此节点可合并几何节点。随机值（Random Value）— 此节点可生成随机值，供其他节点使用。以上为完成添加彩色糖物体的渲染图。以上为甜甜圈添加彩色糖物体的实际操作界面。" }, { "title": "纹理绘制 Texture Paint", "url": "/posts/%E7%BA%B9%E7%90%86%E7%BB%98%E5%88%B6-Texture-Paint/", "categories": "Notes, Blender", "tags": "Blender", "date": "2022-01-27 17:04:00 +0800", "snippet": "若想手动给物体表面材质上色，可以先到阴影模式（Shading）里添加一个图像纹理（Image Texture），然后新建一个图像，再到纹理绘制模式（Texture Paint）中进行绘制即可。在新建图像中，宽度（Width）及高度（Height）并非越大越好。 值的大小会间接影响渲染时长，因此根据场景选择适当的宽高度即可。纹理绘制完毕之后，只需要将该节点的颜色（Color）连接到原理化BSDF（Principled BSDF）的基础色（Base Color），就可以将纹理贴到物体表面了。以上为完成纹理绘制的渲染图。以上为甜甜圈贴上纹理的实际操作界面，以供参考。" }, { "title": "阴影 Shading", "url": "/posts/%E9%98%B4%E5%BD%B1-Shading/", "categories": "Notes, Blender", "tags": "Blender", "date": "2022-01-27 15:02:00 +0800", "snippet": "在阴影模式（Shading）里，节点（Nodes）的执行顺序是由左到右的。Add-on — Node Wrangler在设置（Preferences）的插件（Add-ons）里，开启Node: Node Wrangler。此插件可以让我们在节点界面，按下Ctrl+Shift+LMB浏览该节点的渲染效果。节点 Node这里仅包含我学习过程中有使用到的节点。纹理坐标（Texture Coordinate）— 此节点可校正物体表面的纹理变形问题。噪波纹理（Noise Texture）— 此节点可实现物体表面的噪波纹理。颜色渐变（ColorRamp）— 此节点可实现物体表面的颜色渐变效果。凹凸（Bump）— 此节点可为物体表面添加凹凸元素。混合RGB（MixRGB）— 此节点可将两个颜色合二为一。图像纹理（Image Texture）— 此节点可以将图像转换为纹理贴到物体表面。叠加（Overlay）— 此节点可以将两个不同的颜色/纹理进行叠加处理。以上是添加噪波纹理及凹凸前的渲染图。以上是添加噪波纹理及凹凸后的渲染图。以上是添加噪波纹理及凹凸的实际操作界面，以供参考。" }, { "title": "材质 Material", "url": "/posts/%E6%9D%90%E8%B4%A8-Material/", "categories": "Notes, Blender", "tags": "Blender", "date": "2022-01-27 01:40:00 +0800", "snippet": "若想给一个物体上色，只需要在该物体上添加材质（Material）即可。此操作可以在材质属性（Material Properties）中完成。材质属性（Material Properties）可以在Blender界面右边的属性栏（Properties）中找到。材质有许多不同的参数可进行调节，以下是不同材质对物体表面的影响。这里仅记录使用过的工具，会随着自己学习使用到的慢慢添加。基础色（Base Color）— 物体的表面色次表面（Subsurface）— 物体的表面通透度次表面半径（Subsurface Radius）— 物体的表面各颜色的通透度糙度（Roughness）— 物体表面的粗糙度法向（Normal）— 调整表面的形态" }, { "title": "渲染 Rendering", "url": "/posts/%E6%B8%B2%E6%9F%93-Rendering/", "categories": "Notes, Blender", "tags": "Blender", "date": "2022-01-26 03:54:00 +0800", "snippet": "相机视图 Camera View若想快速定位相机，可先在视窗调整到想要的位置。随后按下组合键Ctrl+Alt+Numpad 0，或是View &gt; Align View &gt; Align Active Camera to View点击即可。渲染引擎 Render Engine渲染引擎可以在渲染属性（Render Properties）中找到。Eevee渲染引擎渲染效率高，不包含光线追踪。以上是Eevee渲染引擎的原始渲染图，可见由于Eevee渲染引擎不包含光线追踪，因此在实时渲染时会产生不真实的阴影。为了优化Eevee渲染引擎的阴影渲染效果，可以在光线物体的数据属性（Object Data Properties）里，调整阴影（Shadow）里的偏移数值（Bias）。同时为了优化阴影的细腻度，可到渲染属性（Render Properties）中，提高阴影里的矩形尺寸（Cube Size）。以上是调整了偏移数值及提高矩形尺寸后的渲染图。为了实现较为真实的阴影渲染效果，可以在渲染属性（Render Properties）里开启环境光遮蔽（Ambient Occlusion）。以上是开启环境光遮蔽后的渲染图。Cycles渲染引擎渲染时间长，包含光线追踪。以上是Cycle渲染引擎的原始渲染图，可见此渲染引擎所渲染出的图效果极佳，但需花费较长的渲染时间。Sample采样采样次数越高，渲染图中的物体就越清晰。" }, { "title": "雕刻 Sculpting", "url": "/posts/%E9%9B%95%E5%88%BB-Sculpting/", "categories": "Notes, Blender", "tags": "Blender", "date": "2022-01-26 03:32:00 +0800", "snippet": "雕刻有很多不同的工具，各工具都采用不同的刷子，可对物体产生不同的作用。这里仅记录使用过的工具，会随着自己学习使用到的慢慢添加。抓起 Grab（G）用于移动/拉伸范围内物体。膨胀 Inflate（I）用于膨胀范围内的物体。光滑 Smooth（Shift+S）用于光滑范围内的物体。" }, { "title": "修改器属性 Modifier Properties", "url": "/posts/%E4%BF%AE%E6%94%B9%E5%99%A8%E5%B1%9E%E6%80%A7-Modifier-Properties/", "categories": "Notes, Blender", "tags": "Blender", "date": "2022-01-26 02:37:00 +0800", "snippet": "修改器属性（Modifier Properties）可以在Blender界面右边的属性（Properties）中找到。其执行的顺序是由上到下的，因此在添加修改器时必须注意修改器的排列顺序。表面细分 Subdivision Surface由于平滑着色后的效果一般，因此为了再进行更细致的处理，可在修改器属性（Modifier Properties）中添加表面细分（Subdivision Surface），提高物体表面的细致度。实体化 Solidify在复制物体后，可对物体进行实体化（Solidify）操作，可在修改器属性（Modifier Properties）中添加实体化（Solidify），就可以对该物体进行宽厚度、偏移量等进行修改了。缩裹 Shrinkwrap对内层物体进行修改后，若想快速让外层物体吸附到内层物体，可在修改器属性（Modifier Properties）中添加缩裹（Shrinkwrap）修改器，并在目标（Target）选择要吸附的物体，就可以使外层的物体吸附到内层的物体上了。" }, { "title": "功能 Functions", "url": "/posts/%E5%8A%9F%E8%83%BD-Functions/", "categories": "Notes, Blender", "tags": "Blender", "date": "2022-01-26 01:15:00 +0800", "snippet": "顶点调整 Edge Editing逐个调整顶点的效率非常低，因此可以在编辑模式（Edit Mode）下按下快捷键 O开启衰减编辑（Proportional Editing）。 首次开启时的编辑范围会特别大，通过滚动滚轮可缩小编辑范围。开启衰减编辑后，对于顶点的所有编辑都会对该顶点周围的顶点造成一定的效果。着色 Shading若想对平直的表面进行平滑着色处理，可以右击物体，选择平滑着色（Shade Smooth）。由于平滑着色后的效果一般，因此为了再进行更细致的处理，可到修改器属性（Modifier Properties），添加表面细分（Subdivision Surface）。吸附 Snap在修改某物体之上的物体时，物体之间会因为形状不同而产生断层。为了解决这个问题，可以在编辑模式下 ，开启吸附功能（Snap），并根据需求选择吸附的类型。这样对上层物体进行修改时，上层物体就会根据选择对下层物体进行吸附。" }, { "title": "快捷键 Shortcut Keys", "url": "/posts/%E5%BF%AB%E6%8D%B7%E9%94%AE-Shortcut-Keys/", "categories": "Notes, Blender", "tags": "Blender", "date": "2022-01-25 17:45:00 +0800", "snippet": "使用快捷键可以提高效率。这里仅记录使用过的快捷键，会随着自己学习使用到的慢慢添加。一般 GeneralG — 移动 GrabH — 隐藏物体 HideAlt+H — 显示隐藏物体 Unhide AllCtrl+Tab — 模式选择 Mode SelectionAlt+G — 恢复位置 Clear PositionShift+` — 移动视角 Pan编辑模式 Edit ModeO — 衰减编辑 Proportional EditingE — 挤出面 ExtrudeAlt+LMB — 选择顶点环 Select Edge Loop雕刻模式 Sculpting ModeF — 范围 RadiusShift+F — 力度 StrengthLMB — 使用雕刻工具Ctrl+LMB — 消除该雕刻工具作用" } ]
