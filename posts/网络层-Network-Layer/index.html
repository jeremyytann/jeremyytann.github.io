<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="计算机网络 2 — 物理层" /><meta property="og:locale" content="en" /><meta name="description" content="2.1 物理层的基本概念" /><meta property="og:description" content="2.1 物理层的基本概念" /><link rel="canonical" href="http://localhost:4000/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-2-%E7%89%A9%E7%90%86%E5%B1%82/" /><meta property="og:url" content="http://localhost:4000/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-2-%E7%89%A9%E7%90%86%E5%B1%82/" /><meta property="og:site_name" content="Jeremy’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-03-05T13:01:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="计算机网络 2 — 物理层" /><meta name="twitter:site" content="@tanchiachun" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-03-05T13:01:00+08:00","datePublished":"2022-03-05T13:01:00+08:00","description":"2.1 物理层的基本概念","headline":"计算机网络 2 — 物理层","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-2-%E7%89%A9%E7%90%86%E5%B1%82/"},"url":"http://localhost:4000/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-2-%E7%89%A9%E7%90%86%E5%B1%82/"}</script><title>网络层 Network Layer | Jeremy's Blog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Jeremy's Blog"><meta name="application-name" content="Jeremy's Blog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css" integrity="sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ" crossorigin="anonymous"><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/avatar/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Jeremy's Blog</a></div><div class="site-subtitle font-italic">My Study Diary</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/jeremyytann" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/tanchiachun" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['tanchiachun2014','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>网络层 Network Layer</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4 pb-5"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>网络层 Network Layer</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1648197360" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Mar 25, 2022 </em> </span><div class="d-flex justify-content-between"> <span> By <em> <a href="https://twitter.com/tanchiachun">Tan Chia Chun</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="6825 words"> <em>37 min</em> read</span></div></div></div><div class="post-content"><h2 id="网络层提供的两种服务"><span class="mr-2"><strong>网络层提供的两种服务</strong></span><a href="#网络层提供的两种服务" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><p>网络层应该向运输层提供这样的服务，曾<strong>引起了长期的争论</strong>。</p><p>争论焦点的实质是：<strong>数据的可靠传输应该由网络还是端系统来负责？</strong></p><h3 id="面向连接"><span class="mr-2"><strong>面向连接</strong></span><a href="#面向连接" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>面向连接的服务，即虚电路 (virtual circuit)。虚电路<strong>只是一种逻辑连接，分组沿着这条逻辑连接按照存储转发方式传送，而非真正建立一条物理连接</strong>。在两台计算机进行通信时，<strong>先由网络建立连接，之后的数据均通过该连接进行，由网络保证数据传输的可靠性</strong>。其支持方以电信公司为代表。</p><h3 id="无连接"><span class="mr-2"><strong>无连接</strong></span><a href="#无连接" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>无连接的服务，即数据报 (datagram)。网络<strong>在发送数据时，不需要先建立连接，每个分组在网络中独立传送，与其前后的分组无关</strong>。<strong>网络层不保证服务质量</strong>，分组可能出错、丢失、重复和失序，也不保证分组传送的时限。其支持方以 Internet 为代表，TCP/IP 就是采用数据报服务。</p><h2 id="网际协议-ip"><span class="mr-2"><strong>网际协议 IP</strong></span><a href="#网际协议-ip" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><p>网际协议 IP 是 TCP/IP 体系中两个最重要的协议之一。与 IP 协议配套使用的还有四个协议：</p><ul><li>地址解析协议 (Address Resolution Protocol, ARP)<li>逆地址解析协议 (Reverse Address Resolution Protocol, RARP)，已淘汰不使用了<li>网际控制报文协议 (Internet Control Message Protocol, ICMP)<li>网际组管理协议 (Internet Group Management Protocol, IGMP)</ul><h3 id="分类的-ip-地址"><span class="mr-2"><strong>分类的 IP 地址</strong></span><a href="#分类的-ip-地址" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>IP 地址是给连接到互联网上的每一台主机的每一个接口，分配一个在<strong>全世界范围内是唯一的 32 位标识符</strong>。IP 地址现在由互联网名字和数字分配机构 (Internet Corporation for Assigned Names and Numbers, ICANN) 进行分配。</p><p><img data-src="/assets/img/ComputerNetwork/CN-4/IPType.png" alt="" style="border-radius: 5%" data-proofer-ignore></p><p>IP 地址被<strong>分为 A, B, C, D, E 五类</strong>，每一类地址都<strong>包含网络号以及主机号两个字段</strong>。其表示方法为点分十进制记法 (dotted decimal notation)。</p><p>曾经 B 类地址中的网络地址 128.0.0.0 和 C 类地址中的网络地址 192.0.0.0 都是规定不指派的，但现在都可以指派了。其中还有一些有特殊含义的 IP 地址，像是<strong>全 0 表示本网络或本主机的 IP 地址、全 1 表示广播地址的 IP 地址以及网路号为 127 用于本地软件环回测试的 IP 地址</strong>。</p><h3 id="ip-地址与硬件地址"><span class="mr-2"><strong>IP 地址与硬件地址</strong></span><a href="#ip-地址与硬件地址" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><code class="language-plaintext highlighter-rouge">物理地址</code></p><p><strong>数据链路层和物理层使用的地址</strong>，被<strong>存放在数据链路层的帧中</strong>。</p><p><code class="language-plaintext highlighter-rouge">IP 地址</code></p><p><strong>网络层和以上各层使用的地址</strong>，是一种<strong>逻辑地址</strong>，被<strong>存放在 IP 包头部</strong>。</p><h3 id="arp-与-rarp-协议"><span class="mr-2"><strong>ARP 与 RARP 协议</strong></span><a href="#arp-与-rarp-协议" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><code class="language-plaintext highlighter-rouge">ARP协议 (Address Resolution Protocol)</code></p><p>全称为 RFC 826: An Ethernet Address Resolution Protocol。</p><p>每一台主机都设有一个 <strong>ARP 高速缓存 (ARP cache)</strong>，里面<strong>有本局域网上的各主机和路由器的 IP 地址到硬件地址的映射表</strong>。ARP <strong>解决同一局域网中的主机或路由器的 IP 地址和硬件地址的映射问题</strong>。如果目的主机不在本局域网内，IP 包就需要经由路由器转发。此时在局域网内要完成的是路由器 IP 与物理地址的映射。</p><p><code class="language-plaintext highlighter-rouge">RARP协议 (Reversed Address Resolution Protocol)</code></p><p>旧协议，作用是<strong>使只知道自己硬件地址的主机能够通过 RARP 协议找出其 IP 地址。</strong>现在的 DHCP 协议已经包含了 RARP 协议的功能。</p><h3 id="ip-数据报格式"><span class="mr-2"><strong>IP 数据报格式</strong></span><a href="#ip-数据报格式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><code class="language-plaintext highlighter-rouge">版本 Version</code></p><p>4bit，IP 协议的版本，目前的 IP 协议版本号为 4，即 IPv4。</p><p><code class="language-plaintext highlighter-rouge">首部长度 IHL</code></p><p>4bit，IP 包头长度，最小 5，最大 15，单位为 word (32bit)。</p><p><code class="language-plaintext highlighter-rouge">区分服务 Type of Service</code></p><p>1字节，服务类型，目前<strong>很多路由器忽略该字段</strong>。</p><p><code class="language-plaintext highlighter-rouge">总长度 Total Length</code></p><p>2字节，<strong>IP包总长度，包含头部和数据</strong>，单位为字节。</p><p><code class="language-plaintext highlighter-rouge">标识 Identification</code></p><p>2字节，是一个计数器，<strong>用以产生 IP 包的标识</strong>。当一个 IP 包超过数据链路层 MTU 时，就需要分片传输。<strong>分片的多个包具有相同的标识，便于接收端重组</strong>。</p><p><code class="language-plaintext highlighter-rouge">标志 Flag</code></p><p>3bit，目前只使用两个Flag，分别是：</p><ul><li>1bit, <strong>Don’t Fragment, DF</strong>。当 DF = 0 时允许分片。<li>1bit, <strong>More Fragment, MF</strong>。当 MF = 1 时表示后面还有分片，而 MF = 0 则表示最后一片。</ul><p><code class="language-plaintext highlighter-rouge">片偏移 Fragment Offset</code></p><p>13bit，片偏移，较长的<strong>包在分片后，某片在原分组中的相对位置</strong>，以 8 字节为单位。</p><p><code class="language-plaintext highlighter-rouge">生存时间 Time To Live</code></p><p>1字节，生存时间，<strong>IP 包在网络中可通过的路由器个数的最大值</strong>。IP 包每经过一个路由器则 TTL 减 1，TTL 为 0 时就丢弃，并向源主机发送一个告警包。Windows 操作系统一般为 128，UNIX 操作系统一般为 255，Linux 一般为 64。</p><p><code class="language-plaintext highlighter-rouge">协议 Protocol</code></p><p>8bit，协议字段，指出<strong>此数据报携带的数据是使用什么协议</strong>，以便使目的主机的 IP 层知道应该将数据部分上交给哪个协议进行处理。</p><p><code class="language-plaintext highlighter-rouge">首部校验和 Header checksum</code></p><p>2字节，只<strong>检验数据报的首部</strong>，不包括数据部分。</p><p><code class="language-plaintext highlighter-rouge">源地址 Source address</code></p><p>4字节，源 IP 地址。</p><p><code class="language-plaintext highlighter-rouge">目标地址 Destination address</code></p><p>4字节，目的 IP 地址。</p><h3 id="校验和算法"><span class="mr-2"><strong>校验和算法</strong></span><a href="#校验和算法" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><strong>对 IP 包头</strong>，每 16 位求反，循环相加，和再求反。若结果为 0 则保留。否则丢弃该数据报。</p><h2 id="划分子网和构造超网"><span class="mr-2"><strong>划分子网和构造超网</strong></span><a href="#划分子网和构造超网" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><p>由于 ARPANET 早期，<strong>IP 地址的设计不够合理</strong>。</p><ol><li>分类 IP 地址无法适应 Internet 快速发展的需要，每个 A 类地址的主机数超过 1000 万，B 类地址也超过 6 万。有的单位申请了一个 B 类地址网络，连接的主机数却不多，导致 <strong>IP 地址空间的利用率有时很低</strong>，造成 IP 地址的浪费，还会使得 IP 地址空间的资源过早被用完。<li>为<strong>每一个物理网络分配一个网络号会使路由表变得太大</strong>，因而使网络性能变坏。<li><strong>两级 IP 地址不够灵活</strong>。有些情况下，一个单位需要在新的地点马上开通一个新的网络。但在申请到一个新的 IP 地址之前，新增加的网络是不可能连接到互联网上工作的。而我们希望的是，一个单位能随时灵活的增加本单位的网络，不必事先到互联网管理机构去申请新的网络号。这是两级 IP 地址无法做到的。</ol><p>为了解决上述问题，就在 <strong>IP 地址中增加了一个子网号字段</strong>，使<strong>两级 IP 地址变为三级 IP 地址</strong>，就能较好地解决上述问题，使用起来也更灵活。而这就是<strong>划分子网</strong>。</p><h3 id="划分子网"><span class="mr-2"><strong>划分子网</strong></span><a href="#划分子网" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><code class="language-plaintext highlighter-rouge">基本思想</code></p><p>一个拥有多个物理网络的单位可按照物理网络划分为若干个子网 (subnet)。<strong>划分子网的方法是从网络的主机号借用若干位作为子网号 (subnet-id)</strong>。因此两级 IP 地址在本单位内部就变为了三级 IP 地址。</p><ul><li>原来的 IP 地址 ::= 网络号，主机号<li>变为了 IP 地址 ::= 网络号，子网号，主机号</ul><p>其他网络发来的 IP 数据报，仍然根据 IP 数据报的目的网络号 net-id，找到本网络的路由器。此路由器收到 IP 数据报后，再按照目的网络号 net-id 和子网号 subnet-id 找到目的子网。</p><h3 id="子网掩码"><span class="mr-2"><strong>子网掩码</strong></span><a href="#子网掩码" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>从 IP 数据报的首部无法看出源主机或目的主机所连接的网络是否进行了子网的划分，这是因为 32 位的 IP 地址本身以及数据报的首部都没有包含任何有关子网划分的信息。因此就有了子网掩码。</p><p><strong>子网掩码是一个网络或一个子网的重要属性</strong>，在路由寻址中发挥着重要作用。</p><p><img data-src="/assets/img/ComputerNetwork/CN-4/Subnet.png" alt="" style="border-radius: 5%" data-proofer-ignore></p><p><strong>使用子网掩码的好处</strong>是，不管网络有没有划分子网，<strong>只要把子网掩码和目的 IP 地址进行逐位的与运算，就能立即得出子网网络地址</strong>。</p><h3 id="使用子网掩码的分组转发过程"><span class="mr-2"><strong>使用子网掩码的分组转发过程</strong></span><a href="#使用子网掩码的分组转发过程" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>使用子网划分后，<strong>路由表必须包含以下三项基本信息</strong>：<strong>目的网络地址、子网掩码和下一跳地址</strong>。</p><p>在划分子网的情况下，<strong>路由器的转发流程</strong>如下：</p><ol><li>从收到的分组的首部提取目的 IP 地址 D。<li>先用与该路由器直接相连各网络的子网掩码与 D 逐位相与，看是否和相应的网络地址匹配。若匹配，则将分组直接交付。否则就间接交付，执行 3。<li>若路由表中有目的地址为 D 的特定主机路由，则将分组传送给指明的下一跳路由器。否则执行 4。<li>对路由表中的每一行的子网掩码与 D 逐位相与，若其结果与该行的目的网络地址匹配，则将分组传送给该行指明的下一跳路由器。否则执行 5。<li>若路由表中有一个默认路由，则将分组传送给路由表中所指明的默认路由器。否则执行 6。<li>报告中转发分组出错。</ol><p>其<strong>核心操作</strong>是将目的 IP 地址与路由表中子网掩码相与，并判断是否与目的网络地址匹配。</p><p><code class="language-plaintext highlighter-rouge">主机发送数据报时判断目的地址是否在本地子网的方法</code></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>if ((目的地址 &amp; subnet mask) == (主机地址 &amp; subnet mask))
  目的地址在本地子网，直接交付
else
  数据报发往gateway
end if
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">路由器查找路由表进行表项匹配的过程</code></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>if ((目的地址 &amp; subnet mask) == 目的网络地址)
  数据包发往该表项的网络出口
end if
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">在子网内直接交付过程</code></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>查找 ARP 缓存，是否有目的 IP 地址对应的 MAC 地址

if (目的 MAC 地址在 ARP 缓存中)
  将 IP 数据包封装成帧后，在局域网内向目的 MAC 地址直接发送帧
else
  在子网内广播发送 ARP 请求，目的主机收到请求后返回 ARP 应答，由此得知目的主机 MAC 地址
end if
</pre></table></code></div></div><h3 id="无分类编制-cidr"><span class="mr-2"><strong>无分类编制 CIDR</strong></span><a href="#无分类编制-cidr" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>全称为 Classless Inter-Domain Routing。</p><p>其<strong>主要特点</strong>有：</p><ul><li><strong>消除了传统 A 类、B 类和 C 类地址以及划分子网的概念</strong>。<li>使用各种长度的<strong>网络前缀</strong>，来代替分类地址中过的网络号和子网号。<li>IP 地址从三级编址<strong>回到了两级编址</strong>，IP 地址 ::= 网络前缀，主机号<li>使用<strong>斜线记法 (slash notation)</strong>，又称 CIDR 记法，即在 <strong>IP 地址后加一个斜线，后跟网络前缀所占的位数</strong>，如 <strong>128.14.35.7/20 表示该地址的高 20 位是网络前缀</strong>。<li><strong>网络前缀都相同的连续的 IP 地址组成 CIDR 地址块</strong>，如 128.14.32.0/20 表示的 CIDR 地址块就有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>12</mn></msup></mrow><annotation encoding="application/x-tex">2^{12}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> 个地址，从 128.14.32.0 至 128.14.47.255。</ul><p><code class="language-plaintext highlighter-rouge">路由聚合 (route aggregation)</code></p><p>由于一个 CIDR 地址块中有很多地址，所以在<strong>路由表中就利用 CIDR 地址块来查找目的网络</strong>。这种地址的聚合常称为路由聚合，它<strong>使得路由表中的一个项目可以表示原来传统分类地址的很多个路由</strong>，可以减少路由表中的表项个数，并减少路由器之间交换的路由信息量。路由聚合<strong>也称为构成超网 (supernetting)</strong>，这是<strong>因为 CIDR地址块大多包含多个 C 类地址</strong>。</p><p><code class="language-plaintext highlighter-rouge">地址掩码</code></p><p>CIDR <strong>不使用子网，但仍使用地址掩码这个名词</strong>。如 /20 的地址掩码为：</p><p>11111111 11111111 11110000 00000000。</p><p><code class="language-plaintext highlighter-rouge">最长前缀匹配</code></p><p>最长前缀匹配<strong>又称为最长匹配或最佳匹配</strong>。</p><p>对于<strong>查找路由表时的匹配结果</strong>，<strong>应该从中选择具有最长前缀匹配的路由</strong>。这是因为<strong>网络前缀越长</strong>，其<strong>地址块就越小</strong>，因而<strong>路由就越具体</strong>。</p><h2 id="国际控制报文协议-icmp"><span class="mr-2"><strong>国际控制报文协议 ICMP</strong></span><a href="#国际控制报文协议-icmp" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><p>全称为 RFC 792 : Internet Control Message Protocol，<strong>主要用于报告出错和测试等控制信息</strong>。</p><p>ICMP <strong>位于 IP 层</strong>，ICMP <strong>报文是装在 IP 数据报中</strong>，<strong>作为其中的数据部分传输的</strong>。</p><h3 id="icmp-报文的种类"><span class="mr-2"><strong>ICMP 报文的种类</strong></span><a href="#icmp-报文的种类" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>ICMP 报文的种类有两种，即 <strong>ICMP 差错报告报文和 ICMP 询问报文</strong>。</p><p><strong>差错报告报文有</strong>：</p><p><code class="language-plaintext highlighter-rouge">终点不可达 Destination unreachable</code></p><p>路由器或主机<strong>无法传输报文时</strong>，向源主机发送此报文。</p><p><code class="language-plaintext highlighter-rouge">源点抑制 Source quench</code></p><p>路由器或主机<strong>由于拥塞丢弃报文时</strong>，向源主机发送此报文，使其放慢发送速度。</p><p><code class="language-plaintext highlighter-rouge">超时 Time exceeded</code></p><p>路由器<strong>收到 TTL 字段为 0 的报文时</strong>，向源主机发送此报文。</p><p><code class="language-plaintext highlighter-rouge">参数问题 Parameter problem</code></p><p>路由器或主机<strong>收到的报文中，头部有非法字段时</strong>，丢弃数据报，并向源主机发送此报文。</p><p><code class="language-plaintext highlighter-rouge">改变路由 Redirect</code></p><p>路由器向主机发送此报文，<strong>告知路由改变</strong>，主机下次发送数据报给另外的路由器。</p><p><strong>询问报文有</strong>：</p><p><code class="language-plaintext highlighter-rouge">回送请求或回答 Echo request/reply</code></p><p>用于<strong>测试网络连通性</strong>。</p><p><code class="language-plaintext highlighter-rouge">时间戳请求或回答 Timestamp request/reply</code></p><p>用于<strong>时间同步</strong>。</p><h3 id="icmp-的应用举例"><span class="mr-2"><strong>ICMP 的应用举例</strong></span><a href="#icmp-的应用举例" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><code class="language-plaintext highlighter-rouge">分组网间探测 Ping</code></p><p>全称为 Packet Internet Groper，其<strong>采用 ICMP Echo request/reply 报文</strong>，用以<strong>测试两台主机之间的连通性</strong>。Ping 是应用层直接使用网络层 ICMP 的一个例子，没有通过运输层的 TCP 或 UDP。</p><p><code class="language-plaintext highlighter-rouge">Traceroute / Tracert</code></p><p><strong>采用 ICMP 超时报告报文</strong>，用以<strong>测试到另一台主机所经过的路由信息</strong>。其方法是逐个发出 UDP 报文，其 IP 包头中的 TTL 字段分别设为 1, 2, 3, …，直到到达目的主机。报文路由路径上的路由器会返回 ICMP 超时报文，从该报文即可得知路由器 IP 地址。</p><h2 id="路由算法及协议"><span class="mr-2"><strong>路由算法及协议</strong></span><a href="#路由算法及协议" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><p>在网络中，<strong>路由器依据路由信息（路由表）转发分组</strong>，路由信息是路由协议生成的，路由算法是路由协议的基础和核心。</p><p>理想的路由算法<strong>应该具备的特性</strong>有：</p><ol><li>必须是正确和完整的，即按照得出的路由能够进行正确寻址。<li>在计算上应该简单，不增加过多开销。<li>有自适应性，即能根据通信量和网络拓扑的变化调整路由。<li>应该具有稳定性，即通信量和拓扑稳定时，能快速收敛。<li>应该是公平的，即对所有用户都公平。<li>应该是最佳的，即能找出最好的路由，指的是时延最小、吞吐量最大的路由。</ol><p>但不同情况下的路由需求可能各有侧重，且网络环境不断变化，因此<strong>不存在一种绝对的最佳路由算法</strong>。</p><h3 id="静态路由与动态路由"><span class="mr-2"><strong>静态路由与动态路由</strong></span><a href="#静态路由与动态路由" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><code class="language-plaintext highlighter-rouge">静态路由</code></p><p>静态路由的<strong>选择策略为非自适应路由选择</strong>。此选择策略<strong>简单和开销较小</strong>，但<strong>不能及时适应网络状态的变化</strong>。因此<strong>适用于小规模且变化较少的网络</strong>，由人工设置路由。</p><p><code class="language-plaintext highlighter-rouge">动态路由</code></p><p>动态路由的<strong>选择策略为自适应路由选择</strong>。此选择策略<strong>能较好地适应网络状态的变化</strong>，但<strong>实现起来较为复杂，开销也比较大</strong>。因此<strong>适用于较大规模、频繁变化的网络</strong>，通过专门的算法和协议进行路由的计算。</p><p>两类<strong>典型的动态路由算法</strong>为距离向量 (distance vector) 路由算法以及链路状态 (link state) 路由算法。</p><p><code class="language-plaintext highlighter-rouge">距离向量路由 (distance vector routing)</code></p><p>也称为 Bellman-Ford 路由算法和 Ford-Fulkerson 算法。最初用于 ARPANET，被 RIP 协议采用。</p><p>其<strong>基本思想</strong>是，每个路由器维护一张表，表中给出了到每个目的地的已知最佳距离和线路，并通过与相邻路由器交换距离信息来更新表。路由器会周期性地向所有相邻路由器发送它的距离表，同时也接受每个邻居结点发来的距离表。</p><p><strong>相邻路由器 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> 发来的表中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> 到路由器 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 的距离为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">X_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，本路由器到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> 的距离为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>，则路由器经过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 的距离为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub><mo>+</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">X_i + m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span></strong>。根据不同邻居发来的信息，<strong>计算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub><mo>+</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">X_i + m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>，并取最小值</strong>，更新本路由器的路由表。</p><p>此<strong>算法的缺陷</strong>是无穷计算问题，即<strong>对好消息反应迅速，对坏消息反应迟钝</strong>。</p><p><code class="language-plaintext highlighter-rouge">链路状态路由 (link state routing)</code></p><p>每个<strong>路由器都需要完成 5 步工作</strong>：</p><ol><li>发现它的邻居结点，并学习其网络地址。<li>测量到各邻居结点的延迟或开销。<li>构造一个分组，其中包含所有它刚刚知道的信息。<li>将这个分组发送给其他所有路由器。<li>计算出到每一个其他路由器的最短路径。</ol><p>各<strong>路由器之间动态交换链路状态信息</strong>，每个路由器都<strong>建立一个链路状态数据库</strong>。</p><blockquote><p>链路状态，指本路由器都和哪些路由器相邻，以及该链路的度量 (metric)</p></blockquote><p>链路状态数据库实际上<strong>是全网的拓扑结构图</strong>，在<strong>全网范围内是一致的</strong>，即<strong>链路状态数据库的同步</strong>。</p><p>各路由器根据网络拓扑，<strong>使用 Dijkstra 算法计算从本路由器到其他结点的最佳路径</strong>，构成路由表。</p><h3 id="internet-采用分层次的路由"><span class="mr-2"><strong>Internet 采用分层次的路由</strong></span><a href="#internet-采用分层次的路由" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Internet 规模庞大，任何一台路由器都不可能获取和存储整个 Internet 的路由信息。同时，接入 Internet 的众多网络（管理方）也不希望外界了解自己网络的内部信息。</p><p>因此就有了自治系统 (Autonomous System, AS) 的概念。</p><p><code class="language-plaintext highlighter-rouge">自治系统 (Autonomous System, AS)</code></p><p><strong>自治系统是指在单一的技术管理下的一组路由器</strong>，而这些路由器使用一种 AS 内部的路由选择协议和共同的度量以确定分组在该 AS 内的路由。同时还使用一种 AS 之间的路由选择协议，用以确定分组在 AS 之间的路由。一个 AS 可使用多种内部路由选择协议和度量，但对其他 AS 表现出的是单一和一只的路由选择策略。</p><p>在自治系统的背景下，Internet 路由协议可分为两类，即：</p><p><code class="language-plaintext highlighter-rouge">内部网关协议 (Interior Gateway Protocol, IGP)</code></p><p>内部网关协议，是<strong>自治系统内部使用的路由选择协议</strong>。</p><p>自治系统内部的路由选择又称为<strong>域内路由选择 (intradomain routing)</strong>。</p><p>这类路由协议使用得最多，如 RIP 和 OSPF 协议。</p><p><code class="language-plaintext highlighter-rouge">外部网关协议 (External Gateway Protocol, EGP)</code></p><p>若<strong>源站和目的站处在不同的自治系统中</strong>，当<strong>数据报传到一个自治系统的边界时</strong>，就<strong>需要使用一种协议路由选择信息传递到另一个自治系统</strong>中，这样的协议就称为外部网关协议。</p><p>自治系统之间的路由选择又称为<strong>域间路由选择 (interdomain routing)</strong>。</p><p>应用最为广泛的外部网关协议为 BGP-4。</p><h3 id="routing-information-protocol-rip-协议"><span class="mr-2"><strong>Routing Information Protocol, RIP 协议</strong></span><a href="#routing-information-protocol-rip-协议" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>其对应 RFC1058: Routing Information Protocol，属于<strong>距离向量路由协议</strong>。</p><p><strong>其特点</strong>是，<strong>简单，适用于小规模网络中的路由</strong>。RIP 中的<strong>距离定义是路由器条数 (hop count)</strong>。</p><p>其最<strong>长距离为 15</strong>，即允许的最长路径中最多包含 15 个路由器，距离为 <strong>16 则表示不可达</strong>。</p><p><strong>RIP 协议的三个要点</strong>是：</p><ol><li><strong>仅和相邻路由器交换信息</strong>。<li><strong>交换的信息是当前本路由器所知道的全部信息</strong>，即自己的路由表。<li><strong>按固定的时间间隔交换路由信息</strong>，典型值为 30 秒。</ol><p><strong>其优点</strong>有：</p><ul><li><strong>实现简单，开销较小</strong>，便于计算。</ul><p><strong>其缺点</strong>有：</p><ul><li>当<strong>网络出现故障时</strong>，要经过<strong>比较长的时间才能将此信息传送到所有路由器</strong><li><strong>支持的网络规模有限</strong>，最大距离为 15，距离为 16 则不可达。<li>路由器之间交换的路由信息是路由器中的完整路由表，<strong>随着网络规模的扩大，开销也会随之增加</strong>。</ul><p><code class="language-plaintext highlighter-rouge">RIP 报文格式</code></p><p><img data-src="/assets/img/ComputerNetwork/CN-4/RIP.png" alt="" style="border-radius: 5%" data-proofer-ignore></p><h3 id="open-shortest-path-first-协议"><span class="mr-2"><strong>Open Shortest Path First 协议</strong></span><a href="#open-shortest-path-first-协议" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>其对应 RFC2328: OSPF Version 2，属于<strong>链路状态路由协议</strong>。</p><p>OSPF <strong>不用 UDP，而是直接用 IP 数据报传送。</strong></p><p><strong>其优点</strong>有：</p><ul><li><strong>收敛速度快</strong>，即当链路状态发生变化时，结点会以洪泛 (flooding) 方式告知所有网络中的其他结点。</ul><blockquote><p>洪泛 (flooding) 是指结点收到分组时，向除输入链路外的所有其他链路发送出去。</p></blockquote><ul><li><strong>适用于较大规模的网络</strong>，因为它仅在链路状态发生变化时才发送洪泛信息，就不会产生很大的通信量。</ul><p>为了管理大规模的网络，OSPF <strong>将一个自治系统再划分为若干个区域</strong>。每个区域都有一个以点分十进制表示的 32 位区域标识符。OSPF <strong>采用层次结构的区域划分</strong>，上层的区域称为<strong>主干区域 (backbone area)</strong>，主干区域的作用是<strong>用来连通其他在下层的区域</strong>。其<strong>标识符规定为 0.0.0.0</strong>。</p><p><strong>划分区域的好处</strong>是，利用洪泛法<strong>交换链路状态信息的范围局限在一个区域</strong>，而不是整个自治系统。这可以<strong>减少整个网络上的通信量</strong>。</p><h3 id="外部网关路由协议-bgp"><span class="mr-2"><strong>外部网关路由协议 BGP</strong></span><a href="#外部网关路由协议-bgp" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>BGP 全称为 Border Gateway Protocol，是<strong>不同自治系统的路由器之间交换路由信息的协议</strong>。</p><p><strong>—————— 还有</strong></p><h3 id="路由器-router"><span class="mr-2"><strong>路由器 Router</strong></span><a href="#路由器-router" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><strong>—————— 还有</strong></p><h3 id="网络的控制平面与数据平面"><span class="mr-2"><strong>网络的控制平面与数据平面</strong></span><a href="#网络的控制平面与数据平面" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><code class="language-plaintext highlighter-rouge">控制平面 (control plane)</code></p><p><strong>—————— 还有</strong></p><p><code class="language-plaintext highlighter-rouge">数据平面 (data plane)</code></p><p><strong>—————— 还有</strong></p><p><code class="language-plaintext highlighter-rouge">软件定义网络 (Software Defined Networking, SDN)</code></p><p><strong>—————— 还有</strong></p><h2 id="ip-组播"><span class="mr-2"><strong>IP 组播</strong></span><a href="#ip-组播" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><p>组播 (multicast)，又称多播，用于<strong>实现一点对多点的数据传输。</strong></p><p>对于一些网络应用，采用<strong>组播可以大大减少网络流量</strong>，如网络视频服务。</p><p>组播数据报的目的地址写入的是组播组的标识符，然后设法让加入到这个组播组的主机的 IP 地址与组播组的标识符关联起来。组播组的标识符使用 D 类 IP 地址作为组播地址，D 类 IP 地址的前四位是 1110，因此 D 类地址范围是 224.0.0.0 到 239.255.255.255，并且 IP 包头中的协议字段值为 2，表示使用网际组管理协议 IGMP协议。</p><p><strong>组播可分为两种</strong>，一种是只在本局域网上进行硬件组播，另一种则是在互联网的范围进行组播。</p><p><code class="language-plaintext highlighter-rouge">在局域网中的硬件组播</code></p><p>这类组播是<strong>将 MAC 地址中的特定地址段作为组播地址，并与 IP 组播地址形成对应关系</strong>。</p><p><code class="language-plaintext highlighter-rouge">在互联网范围的组播</code></p><p>这类组播，路由器需要支持组播，即组播路由器。主机<strong>通过 IGMP 协议与组播路由器通信，加入或退出某个组播组</strong>。而组播路由器之间则通过组播路由协议实现组播数据报的传输。</p><h2 id="虚拟专用网-vpn-和网络地址转换-nat"><span class="mr-2"><strong>虚拟专用网 VPN 和网络地址转换 NAT</strong></span><a href="#虚拟专用网-vpn-和网络地址转换-nat" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><h3 id="网络地址转换-nat"><span class="mr-2"><strong>网络地址转换 NAT</strong></span><a href="#网络地址转换-nat" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>RFC 1918 定义了一些<strong>专用地址 (private address)</strong>：</p><ul><li>10.0.0.0 ~ 10.255.255.255 (CIDR 记法为 10/8)<li>172.16.0.0 ~ 172.31.255.255 (CIDR 记法为 172.16/12)<li>192.168.0.0 ~ 192.168.255.255 (CIDR 记法为 192.168/16)</ul><p>这些地址<strong>只能用于一个机构的内部通信</strong>，而<strong>不能用于和互联网上的主机通信</strong>。互联网中的所有路由器，<strong>对目的地址为专用地址的数据报一律不进行转发</strong>。</p><p>企业与机构内部网络使用专用地址的<strong>优点是可减少 IP 地址空间的占用，同时还可提高安全性</strong>。</p><p><strong>NAT 的基本工作原理</strong>是，当私有网的主机和公共网的主机通信的 IP 包经过 NAT 网关时，NAT 路由器会将 IP 包中的源 IP 或目的 IP 在私有 IP 和 NAT 的公共 IP 之间进行转换。NAT 路由器内部使用 TCP/UDP 端口号实现外网数据包向内网地址的转换。</p><h3 id="虚拟专用网-vpn"><span class="mr-2"><strong>虚拟专用网 VPN</strong></span><a href="#虚拟专用网-vpn" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>有时一个很大的企业或机构的许多部门分布的范围很广，这些部门通常要互相交换信息，有两种实现方式：</p><ul><li>租用专用线路，形成专用网。这种方法简单方便，但成本高昂。<li>利用公用的互联网作为本机构各专用网之间的通信载体，形成VPN。</ul><p><strong>VPN 涉及的技术</strong>包括隧道 (tunnel)、加密、身份认证等。</p><p><strong>基于互联网建立 VPN 的两种情形</strong>有：</p><ul><li><strong>内部网络通过互联网互连</strong>，这可以采用 IPSec 的 ESP 隧道模式。<li><strong>远程用户访问内部网</strong> (remote access VPN)，其访问方式有拨号虚拟专用网 (Virtual Private Dialup Network, VPDN) 和基于 SSL 的 VPN 技术，后者的优点是客户端不需要额外安装或配置软件。</ul><p>通过公共网络传输的数据内容<strong>均经过加密</strong>，<strong>外部仅能通过 IP 分组头得知 R1 和 R2 在通信。</strong></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/notes/'>Notes</a>, <a href='/categories/computer-network/'>Computer Network</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/computer-network/" class="post-tag no-text-decoration" >Computer Network</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%E7%BD%91%E7%BB%9C%E5%B1%82+Network+Layer+-+Jeremy%27s+Blog&url=https%3A%2F%2Fjeremyytann.github.io%2Fposts%2F%25E7%25BD%2591%25E7%25BB%259C%25E5%25B1%2582-Network-Layer%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=%E7%BD%91%E7%BB%9C%E5%B1%82+Network+Layer+-+Jeremy%27s+Blog&u=https%3A%2F%2Fjeremyytann.github.io%2Fposts%2F%25E7%25BD%2591%25E7%25BB%259C%25E5%25B1%2582-Network-Layer%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fjeremyytann.github.io%2Fposts%2F%25E7%25BD%2591%25E7%25BB%259C%25E5%25B1%2582-Network-Layer%2F&text=%E7%BD%91%E7%BB%9C%E5%B1%82+Network+Layer+-+Jeremy%27s+Blog" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/Advanced-Dart/">Advanced Dart</a><li><a href="/posts/Basics-Of-Dart/">Basics of Dart</a><li><a href="/posts/UML-Class-Diagram/">UML Class Diagram</a><li><a href="/posts/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F-Selection-Sort/">选择排序 Selection Sort</a><li><a href="/posts/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-Merge-Sort/">归并排序 Merge Sort</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/blender/">Blender</a> <a class="post-tag" href="/tags/computer-network/">Computer Network</a> <a class="post-tag" href="/tags/algorithm/">Algorithm</a> <a class="post-tag" href="/tags/sorting/">Sorting</a> <a class="post-tag" href="/tags/object-oriented-programming/">Object-Oriented Programming</a> <a class="post-tag" href="/tags/dart/">Dart</a> <a class="post-tag" href="/tags/mvc/">MVC</a> <a class="post-tag" href="/tags/operating-system/">Operating System</a> <a class="post-tag" href="/tags/software-architecture/">Software Architecture</a> <a class="post-tag" href="/tags/uml/">UML</a></div></div></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"><div class="card-body"> <em class="small" data-ts="1646203860" data-df="ll" > Mar 2, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>计算机网络概述</h3><div class="text-muted small"><p> 计算机网络的定义 计算机网络是一些互相连接的、自治（一个计算机网络连接多台计算机，但各自独立工作）的计算机的集合。其功能主要体现在连通性、资源共享。 计算机网络与分布式系统 分布式系统是建立在网络之上的软件系统。在分布式系统中，一组独立的计算机协同完成一个工作，展现给用户的是一个统一的整体，就像一个系统一样。而计算机网络则没有这种统一性。 计算机网络的分类 计算机网络的...</p></div></div></a></div><div class="card"> <a href="/posts/%E7%89%A9%E7%90%86%E5%B1%82-Physical-Layer/"><div class="card-body"> <em class="small" data-ts="1646456460" data-df="ll" > Mar 5, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>物理层 Physical Layer</h3><div class="text-muted small"><p> 物理层的基本概念 物理层主要任务为确定与传输媒体的接口有关的一些特性，像是： 机械特性 — 接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置等 电气特性 — 接口电缆的各条线上出现的电压的范围 功能特性 — 某条线上出现的某一电平的电压的意义 过程特性 — 对于不同功能的各种可能事件的出现顺序 数据通信的基础知识 信道 (Channel) 一般表示向某一方向传...</p></div></div></a></div><div class="card"> <a href="/posts/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82-Data-Link-Layer/"><div class="card-body"> <em class="small" data-ts="1647511200" data-df="ll" > Mar 17, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>数据链路层 Data Link Layer</h3><div class="text-muted small"><p> 数据链路层设计要点 数据链路层属于计算机网络的底层。 物理层实现了比特流的传输，数据链路层在其基础上实现了帧 (frame) 的传输。 数据链路层传输的协议数据单元 (Protocol Data Unit, PDU) 是帧。数据链路层把网络层交下来的数据构成帧发送到链路上，以及把接收到的帧中的数据取出并上交给网络层。 数据链路层使用的信道类型 点对点信道 这种信道使用一对一的...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82-Data-Link-Layer/" class="btn btn-outline-primary" prompt="Older"><p>数据链路层 Data Link Layer</p></a> <a href="/posts/%E4%BC%A0%E8%BE%93%E5%B1%82-Transport-Layer/" class="btn btn-outline-primary" prompt="Newer"><p>传输层 Transport Layer</p></a></div><script type="text/javascript"> $(function () { const origin = "https://giscus.app"; const iframe = "iframe.giscus-frame"; const lightTheme = "light"; const darkTheme = "dark_dimmed"; let initTheme = lightTheme; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = darkTheme; } let giscusAttributes = { "src": "https://giscus.app/client.js", "data-repo": "jeremyytann/jeremyytann.github.io", "data-repo-id": "R_kgDOG65--w", "data-category": "General", "data-category-id": "DIC_kwDOG65--84CN6so", "data-mapping": "pathname", "data-reactions-enabled": "1", "data-emit-metadata": "0", "data-theme": initTheme, "data-input-position": "bottom", "data-lang": "en", "crossorigin": "anonymous", "async": "" }; let giscusScript = document.createElement("script"); Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value)); document.getElementById("tail-wrapper").appendChild(giscusScript); addEventListener("message", (event) => { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* global theme mode changed */ const mode = event.data.message; const theme = (mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme); const message = { setConfig: { theme: theme } }; const giscus = document.querySelector(iframe).contentWindow; giscus.postMessage({ giscus: message }, origin); } }); }); </script></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://twitter.com/tanchiachun">Tan Chia Chun</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/blender/">Blender</a> <a class="post-tag" href="/tags/computer-network/">Computer Network</a> <a class="post-tag" href="/tags/algorithm/">Algorithm</a> <a class="post-tag" href="/tags/sorting/">Sorting</a> <a class="post-tag" href="/tags/object-oriented-programming/">Object-Oriented Programming</a> <a class="post-tag" href="/tags/dart/">Dart</a> <a class="post-tag" href="/tags/mvc/">MVC</a> <a class="post-tag" href="/tags/operating-system/">Operating System</a> <a class="post-tag" href="/tags/software-architecture/">Software Architecture</a> <a class="post-tag" href="/tags/uml/">UML</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-7W4M2E46LD"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-7W4M2E46LD'); }); </script>
